<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>King   James</title>
  
  <subtitle>筚路蓝缕，以启山林</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2018-04-15T07:12:53.924Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Mr.Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩阵的 SVD 分解</title>
    <link href="http://github.com/2018/04/15/%E7%9F%A9%E9%98%B5%E7%9A%84-SVD-%E5%88%86%E8%A7%A3/"/>
    <id>http://github.com/2018/04/15/矩阵的-SVD-分解/</id>
    <published>2018-04-15T05:49:07.000Z</published>
    <updated>2018-04-15T07:12:53.924Z</updated>
    
    <content type="html"><![CDATA[<p>看似高大上的人工智能、机器学习，实际上都脱不开数学的支持。在这些数学内容中，最重要的无疑是两个部分：代数和概率论。我无法在博客中完整地介绍代数（特别是矩阵论）和概率论，但是将其中部分有趣又重要的内容提出来讲解，还是可行的。</p><p>此篇，我们谈谈矩阵的 SVD 分解。</p><a id="more"></a><h2 id="一些矩阵知识"><a href="#一些矩阵知识" class="headerlink" title="一些矩阵知识"></a>一些矩阵知识</h2><p>首先我们来看一些基本的矩阵知识。</p><h3 id="转置与共轭转置"><a href="#转置与共轭转置" class="headerlink" title="转置与共轭转置"></a>转置与共轭转置</h3><p>矩阵的转置（transpose）是最简单的一种矩阵变换。简单来说，若 $m\times n$ 的矩阵 $\mathbf M$ 的转置记为 $\mathbf M^{\mathsf T}$；则 $\mathbf M^{\mathsf T}$ 是一个 $n\times m$ 的矩阵，并且 $\mathbf M_{i,j} = \mathbf M^{\mathsf T}_{j,i}$。</p><p>因此，矩阵的转置相当于将矩阵按照主对角线翻转；同时，我们不难得出 $\mathbf M = \bigl(\mathbf M^{\mathsf T}\bigr)^{\mathsf T}$。</p><p><img src="https://liam0205.me/uploads/images/mathematics/Matrix_transpose.gif" alt=""></p><p>矩阵的共轭转置（conjugate transpose）可能是倒数第二简单的矩阵变换。共轭转置只需要在转置的基础上，再叠加复数的共轭即可。因此，若以 $\mathbf M^{\mathsf H}$ 记矩阵 $\mathbf M$ 的共轭转置，则有 $\mathbf M_{i,j} = \overline{\bigl(\mathbf M^{\mathsf H}\bigr)_{j,i}}$。</p><h3 id="酉矩阵"><a href="#酉矩阵" class="headerlink" title="酉矩阵"></a>酉矩阵</h3><p>酉矩阵（unitary matrix）是一种特殊的方阵，它满足</p><p>$$ \mathbf U\mathbf U^{\mathsf H} = \mathbf U^{\mathsf H}\mathbf U = I_n.$$</p><p>不难看出，酉矩阵实际上是推广的正交矩阵（orthogonal matrix）；当酉矩阵中的元素均为实数时，酉矩阵实际就是正交矩阵。另一方面，由于 $\mathbf M\mathbf M^{-1} = \mathbf M^{-1}\mathbf M = I_n$，所以酉矩阵 $\mathbf U$ 满足 $\mathbf U^{-1} = \mathbf U^{\mathsf H}$；事实上，这是一个矩阵是酉矩阵的充分必要条件。</p><h3 id="正规矩阵"><a href="#正规矩阵" class="headerlink" title="正规矩阵"></a>正规矩阵</h3><p>同酉矩阵一样，正规矩阵（normal matrix）也是一种特殊的方阵，它要求在矩阵乘法的意义下与它的共轭转置矩阵满足交换律。这也就是说，若矩阵 $\mathbf M$ 满足如下条件，则称其为正规矩阵：</p><p>$$\mathbf M\mathbf M^{\mathsf H} = \mathbf M^{\mathsf H}\mathbf M.$$</p><p>显而易见，复系数的酉矩阵和实系数的正交矩阵都是正规矩阵。显而易见，正规矩阵并不只有酉矩阵或正交矩阵。例如说，矩阵 $\mathbf M = \begin{pmatrix}1 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 \ 1 &amp; 0 &amp; 1\end{pmatrix}$ 即是一个正规矩阵，但它显然不是酉矩阵或正交矩阵；因为</p><p>$$\mathbf M\mathbf M^{\mathsf H} = \begin{pmatrix}2 &amp; 1 &amp; 1 \ 1 &amp; 2 &amp; 1 \ 1 &amp; 1 &amp; 2\end{pmatrix} = \mathbf M^{\mathsf H}\mathbf M.$$</p><h3 id="谱定理和谱分解"><a href="#谱定理和谱分解" class="headerlink" title="谱定理和谱分解"></a>谱定理和谱分解</h3><p>矩阵的对角化是线性代数中的一个重要命题。谱定理（spectral theorem）给出了方阵对角化的一个结论：若矩阵 $\mathbf M$ 是一个正规矩阵，则存在酉矩阵 $\mathbf U$，以及对角矩阵 $\mathbf \Lambda$，使得</p><p>$$\mathbf M = \mathbf U\mathbf \Lambda\mathbf U^{\mathsf H}.$$</p><p>这也就是说，正规矩阵，可经由酉变换，分解为对角矩阵；这种矩阵分解的方式，称为谱分解（spectral decomposition）。</p><h2 id="SVD-分解"><a href="#SVD-分解" class="headerlink" title="SVD 分解"></a>SVD 分解</h2><p>谱定理给出了正规矩阵分解的可能性以及分解形式。然而，对于矩阵来说，正规矩阵是要求非常高的。因此，谱定理是一个非常弱的定理，它的适用范围有限。在实际生产中，我们遇到的很多矩阵都不是正规矩阵。对于这些矩阵，谱定理就失效了。作为谱定理的泛化，SVD 分解对于原矩阵的要求就要弱得多。</p><p>SVD 分解说的是：假设 $\mathbf M$ 是一个 $ m\times n$ 的矩阵，其中的元素全部属于数域 $\mathbb K$（实数域 $\mathbb R$ 或复数域 $\mathbb C$）。那么，存在 $m\times m$ 的酉矩阵 $\mathbf U$ 和 $n\times n$ 的酉矩阵 $\mathbf V$ 使得</p><p>$$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H},$$</p><p>其中 $\mathbf\Sigma$ 是 $m\times n$ 的非负实数对角矩阵；并且 $\mathbf\Sigma$ 对角线上的元素 $\mathbf\Sigma_{i, i}$ 是 $\mathbf M$ 的奇异值。一般来说，我们偏好将这些奇异值按从大到小的顺序排列，这样一来 $\mathbf\Sigma$ 就由 $\mathbf M$ 唯一确定了。</p><p>另一方面，因为 $\mathbf U$ 和 $\mathbf V$ 都是酉矩阵，所以 $\mathbf U$ 和 $\mathbf V$ 的列向量分别张成 $\mathbb K^{m}$ 和 $\mathbb K^{n}$ 的一组标准正交基。我们将 $\mathbf U$ 的列向量记作 $\vec u_i,\; 1 \leqslant i\leqslant m$；将 $\mathbf V$ 的列向量记作 $\vec v_j,\; 1\leqslant j\leqslant n$；同时，将 $\mathbf\Sigma$ 对角线上的第 $i$ 个元素记作 $\sigma_k,\; 1\leqslant k\leqslant\min(m,n)$。那么，SVD 分解实际可以将矩阵 $\mathbf M$ 写作一个求和形式</p><p>$$\mathbf M = \sum_{i = 1}^{\min(m, n)}\sigma_i\vec u_i\vec v_i^{\mathsf T}.$$</p><h3 id="SVD-的计算方法"><a href="#SVD-的计算方法" class="headerlink" title="SVD 的计算方法"></a>SVD 的计算方法</h3><p>了解了 SVD 的介绍和相关几何解释之后，接下来最直接想要知道的就是如何计算一个矩阵的 SVD 了。我们分成几步来探讨这个问题。</p><h4 id="SVD-与特征值"><a href="#SVD-与特征值" class="headerlink" title="SVD 与特征值"></a>SVD 与特征值</h4><p>现在，假设矩阵 $\mathbf M_{m\times n}$ 的 SVD 分解是</p><p>$$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H};$$</p><p>那么，我们有</p><p>$$\begin{aligned}<br>\mathbf M\mathbf M^{\mathsf H} &amp;{}= \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H}\mathbf V\mathbf\Sigma^{\mathsf H}\mathbf U^{\mathsf H} = \mathbf U(\mathbf\Sigma\mathbf\Sigma^{\mathsf H})\mathbf U^{\mathsf H}\<br>\mathbf M^{\mathsf H}\mathbf M &amp;{}= \mathbf V\mathbf\Sigma^{\mathsf H}\mathbf U^{\mathsf H}\mathbf U\mathbf\Sigma\mathbf V^{\mathsf H} = \mathbf V(\mathbf\Sigma^{\mathsf H}\mathbf\Sigma)\mathbf V^{\mathsf H}\<br>\end{aligned}$$</p><p>这也就是说，$\mathbf U$ 的列向量（左奇异向量），是 $\mathbf M\mathbf M^{\mathsf H}$ 的特征向量；同时，$\mathbf V$ 的列向量（右奇异向量），是 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量；另一方面，$\mathbf M$ 的奇异值（$\mathbf\Sigma$ 的非零对角元素）则是 $\mathbf M\mathbf M^{\mathsf H}$ 或者 $\mathbf M^{\mathsf H}\mathbf M$ 的非零特征值的平方根。</p><h4 id="如何计算-SVD"><a href="#如何计算-SVD" class="headerlink" title="如何计算 SVD"></a>如何计算 SVD</h4><p>有了这些知识，我们就能手工计算出任意矩阵的 SVD 分解了；具体来说，算法如下</p><ol><li>计算 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$；</li><li>分别计算 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量及其特征值；</li><li>$\mathbf M\mathbf M^{\mathsf H}$ 的特征向量组成 $\mathbf U$；而 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量组成 $\mathbf V$；</li><li>对 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$ 的非零特征值求平方根，对应上述特征向量的位置，填入 $\mathbf\Sigma$ 的对角元。</li></ol><h4 id="实际计算看看"><a href="#实际计算看看" class="headerlink" title="实际计算看看"></a>实际计算看看</h4><p>现在，我们来试着计算 $\mathbf M = \begin{bmatrix}2 &amp; 4 \ 1 &amp; 3 \ 0 &amp; 0 \ 0 &amp; 0\end{bmatrix}$ 的奇异值分解。计算奇异值分解，需要计算 $\mathbf M$ 与其共轭转置的左右积；这里主要以 $\mathbf M\mathbf M^{\mathsf H}$ 为例。</p><p>首先，我们需要计算 $\mathbf M\mathbf M^{\mathsf H}$，</p><p>$$<br>\mathbf W = \mathbf M\mathbf M^{\mathsf H} = \begin{bmatrix}2 &amp; 4 \ 1 &amp; 3 \ 0 &amp; 0 \ 0 &amp; 0\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 0 &amp; 0 \ 4 &amp; 3 &amp; 0 &amp; 0\end{bmatrix} = \begin{bmatrix}20 &amp; 14 &amp; 0 &amp; 0 \ 14 &amp; 10 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}.<br>$$</p><p>现在，我们要求 $\mathbf W$ 的特征值与特征向量。根据定义 $\mathbf W\vec x = \lambda \vec x$；因此 $(\mathbf W - \lambda\mathbf I)\vec x = \vec 0$。这也就是说</p><p>$$<br>\begin{bmatrix}<br>20 - \lambda &amp; 14 &amp; 0 &amp; 0 \<br>14 &amp; 10 - \lambda &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; -\lambda &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; -\lambda<br>\end{bmatrix}\vec x = \vec 0.<br>$$</p><p>根据线性方程组的理论，若要该关于 $\vec x$ 的方程有非零解，则要求系数矩阵的行列式为 0；也就是</p><p>$$<br>\begin{vmatrix}<br>20 - \lambda &amp; 14 &amp; 0 &amp; 0 \<br>14 &amp; 10 - \lambda &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; -\lambda &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; -\lambda<br>\end{vmatrix} =<br>\begin{vmatrix}<br>20 - \lambda &amp; 14 \<br>14 &amp; 10 - \lambda \<br>\end{vmatrix}\begin{vmatrix}<br>-\lambda &amp; 0 \<br>0 &amp; -\lambda \<br>\end{vmatrix}<br>= 0,<br>$$</p><p>这也就是 $\bigl((20 - \lambda)(10 - \lambda) - 196\bigr)\lambda^2 = 0$；解得 $\lambda<em>{1} = \lambda</em>{2} = 0$, $\lambda<em>{3} = 15 + \sqrt{221} \approx 29.866$, $\lambda</em>{4} = 15 - \sqrt{221} \approx 0.134$。将特征值代入原方程，可解得对应的特征向量；这些特征向量即作为列向量，形成矩阵</p><p>$$\mathbf U = \begin{bmatrix}-0.82 &amp; -0.58 &amp; 0 &amp; 0 \ -0.58 &amp; 0.82 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}.$$</p><p>同理可解得（注意，$\mathbf M\mathbf M^{\mathsf T}$ 和 $\mathbf M^{\mathsf T}\mathbf M$ 的特征值相同）</p><p>$$\mathbf V = \begin{bmatrix}-0.40 &amp; -0.91 \ -0.91 &amp; 0.40\end{bmatrix}.$$</p><p>以及 $\mathbf\Sigma$ 上的对角线元素由 $\mathbf W$ 的特征值的算术平方根组成；因此有</p><p>$$\mathbf\Sigma = \begin{bmatrix}5.46 &amp; 0 \ 0 &amp; 0.37 \ 0 &amp; 0 \ 0 &amp; 0\end{bmatrix}.$$</p><p>因此我们得到矩阵 $\mathbf M$ 的 SVD 分解（数值上做了近似）：</p><p>$$\begin{bmatrix}2 &amp; 4 \ 1 &amp; 3 \ 0 &amp; 0 \ 0 &amp; 0\end{bmatrix} \approx \begin{bmatrix}-0.82 &amp; -0.58 &amp; 0 &amp; 0 \ -0.58 &amp; 0.82 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}5.46 &amp; 0 \ 0 &amp; 0.37 \ 0 &amp; 0 \ 0 &amp; 0\end{bmatrix}\begin{bmatrix}-0.40 &amp; -0.91 \ -0.91 &amp; 0.40\end{bmatrix}$$</p><h3 id="几何上的直观解释"><a href="#几何上的直观解释" class="headerlink" title="几何上的直观解释"></a>几何上的直观解释</h3><p>我们先来看一个例子。假设 $\mathbf M$ 是一个 $m\times n$ 的矩阵，而 $\mathbf x$ 是线性空间 $\mathbb K^n$ 中的向量，则</p><p>$$\mathbf y = \mathbf M\cdot\mathbf x$$</p><p>是线性空间 $\mathbb K^m$ 中的向量。这样一来，矩阵 $\mathbb A$ 就对应了一个从 $\mathbb K^n$ 到 $\mathbb K^m$ 的变换 $T: \mathbb K^n \to \mathbb K^m$，具体来说既是 $\mathbf x\mapsto \mathbf M\cdot\mathbf x$。</p><p>这也就是说，在线性代数中，任意矩阵都能看做是一种变换。这样一来，我们就统一了矩阵和变换。</p><h4 id="旋转变换和反射变换（镜像）"><a href="#旋转变换和反射变换（镜像）" class="headerlink" title="旋转变换和反射变换（镜像）"></a>旋转变换和反射变换（镜像）</h4><p>在线性空间中进行旋转，实际是要改变向量的方向，但是不改变向量的长度和手性。现在假设矩阵 $\mathbf M_{n\times n}$ 是线性空间 $\mathbf R^{n}$ 中的一个旋转变换对应的矩阵，我们来看看它应该是什么样子。</p><p>首先，我们考虑向量内积 $\vec a\cdot\vec b = \lvert\vec a\rvert\lvert\vec b\rvert\cos\langle\vec a,\vec b\rangle$。因为旋转不改变向量的长度，且两个向量经过相同的旋转之后，其夹角保持不变。因此，若 $\mathbf M$ 对应一个旋转变换，那么就必须有</p><p>$$\vec a\cdot\vec b = \mathbf M\vec a\cdot \mathbf M\vec b,$$</p><p>也就是</p><p>$$\vec a\cdot\vec b^{\mathsf T} = \mathbf M\vec a\cdot (\mathbf M\vec b)^{\mathsf T},$$</p><p>这也就是说 $\mathbf M\mathbf M^{\mathsf T} = \mathbf I_{n}$，亦即 $\mathbf M$ 是正交矩阵。</p><p>因此，对于二维的情况，$\mathbf M$ 可以写作 $\begin{bmatrix}\cos\varphi &amp; -\sin\varphi \\ \sin\varphi &amp; \cos\varphi\end{bmatrix}$ 或 $\begin{bmatrix}\cos\varphi &amp; \sin\varphi \\ \sin\varphi &amp; -\cos\varphi\end{bmatrix}$。前者行列式为 $1$ 而后者行列式为 $-1$。既然 $\mathbf M$ 是正交矩阵，那么它的行列式值必然是 $\pm 1$。现在的问题是，行列式为 $1$ 和 $-1$ 究竟哪一个才是旋转？或者两个都是旋转？</p><p>回过头，我们需要注意两件事情。其一，在旋转的定义中，我们提出了旋转保持「手性」；其二，在得出旋转矩阵是正交矩阵的过程中，我们并没有运用到「手性不变」这一特性——因为 $\cos\langle\vec a,\vec b\rangle = \cos\langle\vec b,\vec a\rangle$。</p><p>事实上，若 $\mathbf M$ 的行列式为 $-1$，则该矩阵对应了一个瑕旋转——先旋转 $\varphi$ 而后按直线 $r = k\varphi$ 镜像。考虑 $\varphi - \alpha = 2\varphi - (\varphi + \alpha)$，这一瑕旋转实质上就是按直线 $r = k(\varphi / 2)$ 镜像。</p><p>因此我们说，旋转矩阵是一个行列式为 $1$ 的正定矩阵，其形式为</p><p>$$\begin{bmatrix}\cos\varphi &amp; -\sin\varphi \\ \sin\varphi &amp; \cos\varphi\end{bmatrix},$$</p><p>表示向正方向（通常是逆时针方向）旋转 $\varphi$。对于 $\mathbb R^{2}$ 上的标准正交基 $\begin{bmatrix}1 \\ 0\end{bmatrix}$, $\begin{bmatrix}0 \\ 1\end{bmatrix}$，他们分别被变换为 $\begin{bmatrix}\cos\varphi \\ \sin\varphi\end{bmatrix}$ 和 $\begin{bmatrix}-\sin\varphi \\ \cos\varphi\end{bmatrix}$。</p><p><img src="https://liam0205.me/uploads/images/mathematics/rotation.png" alt=""></p><p>行列式为 $-1$ 的正定矩阵，其形式为</p><p>$$\begin{bmatrix}\cos\varphi &amp; \sin\varphi \\ \sin\varphi &amp; -\cos\varphi\end{bmatrix},$$</p><p>表示按直线 $r = k(\varphi / 2)$ 镜像。</p><h4 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h4><p>在线性空间中进行缩放，实质就是要让线性空间中的每一维独立地进行变换，而不受其他维度影响。这样一来，很显然，对应的矩阵应该是对角矩阵。</p><h4 id="SVD-分解的几何解释"><a href="#SVD-分解的几何解释" class="headerlink" title="SVD 分解的几何解释"></a>SVD 分解的几何解释</h4><p>现在回过头来看 SVD 分解</p><p>$$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H},$$</p><p>在实数范围内讨论，我们实质上是将一个复杂的变换 $M:\mathbb R^{m}\to\mathbb R^{n}$ 分解成了三个变换：旋转/镜像 $U:\mathbb R^{m}\to\mathbb R^{m}$、缩放 $\Sigma:\mathbb R^{m}\to\mathbb R^{n}$、旋转/镜像 $V:\mathbb R^{n}\to\mathbb R^{n}$。</p><p>不失一般性，我们假设 $m = n$ 以及 $U$ 和 $V$ 都是旋转矩阵，则这个过程可以表示为</p><p><img src="https://liam0205.me/uploads/images/mathematics/280px-Singular_value_decomposition.gif" alt=""></p><p>不难发现，$\mathbf V^{\mathsf H}$ 首先将（可能是退化的）单位球旋转（旋转标准正交基），而后经由 $\mathbf \Sigma$ 将单位圆缩放拉伸成椭圆（超空间中的超椭球），再经由 $\mathbf U$ 将超椭球在 $\mathbb K^{m}$ 空间中旋转。而这个超椭球的各个半轴的长度，就是矩阵 $\mathbf M$ 的奇异值，也就是矩阵 $\mathbf \Sigma$ 对角线上的元素。</p><h2 id="SVD-分解的应用"><a href="#SVD-分解的应用" class="headerlink" title="SVD 分解的应用"></a>SVD 分解的应用</h2><p>在化学中，有所谓「结构决定性质、性质决定用途」的说法；这反应了一个事物由内而外的特性和人类运用事物的普遍规律。这一规律放在数学上也一样适用。</p><p>SVD 将矩阵分解成累加求和的形式，其中每一项的系数即是原矩阵的奇异值。这些奇异值，按之前的几何解释，实际上就是空间超椭球各短轴的长度。现在想象二维平面中一个非常扁的椭圆（离心率非常高），它的长轴远远长于短轴，以至于整个椭圆看起来和一条线段没有什么区别。这时候，如果将椭圆的短轴强行置为零，从直观上看，椭圆退化为线段的过程并不突兀。回到 SVD 分解当中，较大的奇异值反映了矩阵本身的主要特征和信息；较小的奇异值则如例中椭圆非常短的短轴，几乎没有体现矩阵的特征和携带的信息。因此，若我们将 SVD 分解中较小的奇异值强行置为零，则相当于丢弃了矩阵中不重要的一部分信息。</p><p>因此，SVD 分解至少有两方面作用：</p><ul><li>分析了解原矩阵的主要特征和携带的信息（取若干最大的奇异值），这引出了主成分分析（PCA）；</li><li>丢弃忽略原矩阵的次要特征和携带的次要信息（丢弃若干较小的奇异值），这引出了信息有损压缩、矩阵低秩近似等话题。</li></ul><p>这两方面的应用实际上是对偶的：因为，按重要度排序之后，一方面我们可以知道哪些信息（奇异值）重要，另一方面我就很自然地就可以丢弃不重要的部分。这里我们以信息的有损压缩为例。</p><p>在实际生活和工作当中，很多信息都能被表示为矩阵形式。例如：图像（参见 <a href="/2017/08/06/pil-tutorial-pixel-operations-and-image-filter/">PIL 简明教程 - 像素操作与图像滤镜</a>）信息，机器学习任务中巨大的特征矩阵等。此处我们循着前文的轨迹，以图像信息的形式直观地展现 SVD 分解在图形压缩中的应用。</p><p>首先让我们回顾一下曾经见过的猫咪，它长这样：</p><p><img src="https://liam0205.me/uploads/images/python/cat.jpg" alt=""></p><p>经过 SVD 分解之后，RGB 三通道的奇异值值分别形如（<a href="/uploads/codes/python/image_svd.py">代码</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[  <span class="number">8.29754663e+04</span>   <span class="number">1.43568761e+04</span>   <span class="number">8.28098602e+03</span>   <span class="number">7.94075752e+03</span></div><div class="line">   <span class="number">6.87204550e+03</span>   <span class="number">4.64118946e+03</span>   <span class="number">3.07326587e+03</span>   <span class="number">2.64043230e+03</span></div><div class="line">   <span class="number">2.34251575e+03</span>   <span class="number">2.08293043e+03</span>   <span class="number">1.81457650e+03</span>   <span class="number">1.73772694e+03</span></div><div class="line">   <span class="number">1.55535238e+03</span>   <span class="number">1.44987605e+03</span>   <span class="number">1.28556279e+03</span>   <span class="number">1.18657598e+03</span></div><div class="line">   <span class="number">1.15156737e+03</span>   <span class="number">1.10588319e+03</span>   <span class="number">1.04069060e+03</span>   <span class="number">9.63555279e+02</span></div><div class="line">   ...</div><div class="line">   <span class="number">2.07308001e+00</span>   <span class="number">2.03810704e+00</span>   <span class="number">2.01670137e+00</span>   <span class="number">1.89766075e+00</span></div><div class="line">   <span class="number">1.78169821e+00</span>]</div><div class="line">[  <span class="number">7.52035286e+04</span>   <span class="number">1.45096769e+04</span>   <span class="number">1.02416708e+04</span>   <span class="number">7.99187399e+03</span></div><div class="line">   <span class="number">5.55763091e+03</span>   <span class="number">4.82795595e+03</span>   <span class="number">3.22590281e+03</span>   <span class="number">2.81678573e+03</span></div><div class="line">   <span class="number">2.47269533e+03</span>   <span class="number">2.05484885e+03</span>   <span class="number">1.87922653e+03</span>   <span class="number">1.67558281e+03</span></div><div class="line">   <span class="number">1.55022246e+03</span>   <span class="number">1.48494502e+03</span>   <span class="number">1.30714569e+03</span>   <span class="number">1.19338672e+03</span></div><div class="line">   <span class="number">1.17078655e+03</span>   <span class="number">1.07687752e+03</span>   <span class="number">1.04558020e+03</span>   <span class="number">9.93807772e+02</span></div><div class="line">   ...</div><div class="line">   <span class="number">2.08166328e+00</span>   <span class="number">2.03020090e+00</span>   <span class="number">1.95633445e+00</span>   <span class="number">1.88738236e+00</span></div><div class="line">   <span class="number">1.80539295e+00</span>]</div><div class="line">[  <span class="number">7.15164941e+04</span>   <span class="number">1.60372342e+04</span>   <span class="number">1.20401757e+04</span>   <span class="number">8.69602152e+03</span></div><div class="line">   <span class="number">5.69604800e+03</span>   <span class="number">3.76913288e+03</span>   <span class="number">3.48390702e+03</span>   <span class="number">3.17683272e+03</span></div><div class="line">   <span class="number">2.73730517e+03</span>   <span class="number">2.32005514e+03</span>   <span class="number">2.08571764e+03</span>   <span class="number">1.76733763e+03</span></div><div class="line">   <span class="number">1.55393096e+03</span>   <span class="number">1.47436741e+03</span>   <span class="number">1.39202168e+03</span>   <span class="number">1.21607022e+03</span></div><div class="line">   <span class="number">1.17991116e+03</span>   <span class="number">1.16377337e+03</span>   <span class="number">1.01255317e+03</span>   <span class="number">9.97811473e+02</span></div><div class="line">   ...</div><div class="line">   <span class="number">2.17604369e+00</span>   <span class="number">2.13041080e+00</span>   <span class="number">1.99837012e+00</span>   <span class="number">1.88718778e+00</span></div><div class="line">   <span class="number">1.80040166e+00</span>]</div></pre></td></tr></table></figure><p>当我们从大到小开始截断，丢弃较小的奇异值并重建图像之后，我们就能得到「压缩之后」的图像了。</p><p>当只取 1 个奇异值时，重建图像如下。基本啥也看不出。</p><p><img src="https://liam0205.me/uploads/images/python/cat_svd_1.jpg" alt=""></p><p>当只取 5 个奇异值时，重建图像如下。此时已经勉强能看出一只猫咪的形象了。</p><p><img src="https://liam0205.me/uploads/images/python/cat_svd_5.jpg" alt=""></p><p>按照观察，在第 20 个奇异值附近，奇异值的大小有数量级的变化（从 <code>+03</code> 跌落至 <code>+02</code>）。因此，当取 20 个奇异值时，重建图像如下；此时猫咪的形象已经很清晰了。</p><p><img src="https://liam0205.me/uploads/images/python/cat_svd_20.jpg" alt=""></p><p>当取用 50 个奇异值时，重建的图像和原图已经相当接近了。</p><p><img src="https://liam0205.me/uploads/images/python/cat_svd_50.jpg" alt=""></p><p>类似地，我们还可以观察取用 <a href="https://liam0205.me/uploads/images/python/cat_svd_100.jpg" target="_blank" rel="external">100</a>/<a href="https://liam0205.me/uploads/images/python/cat_svd_200.jpg" target="_blank" rel="external">200</a>/<a href="https://liam0205.me/uploads/images/python/cat_svd_300.jpg" target="_blank" rel="external">300</a>/<a href="https://liam0205.me/uploads/images/python/cat_svd_400.jpg" target="_blank" rel="external">400</a> 个奇异值时，重建图像得到的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看似高大上的人工智能、机器学习，实际上都脱不开数学的支持。在这些数学内容中，最重要的无疑是两个部分：代数和概率论。我无法在博客中完整地介绍代数（特别是矩阵论）和概率论，但是将其中部分有趣又重要的内容提出来讲解，还是可行的。&lt;/p&gt;
&lt;p&gt;此篇，我们谈谈矩阵的 SVD 分解。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://github.com/categories/Machine-Learning/"/>
    
    
      <category term="Matrix" scheme="http://github.com/tags/Matrix/"/>
    
      <category term="SVD" scheme="http://github.com/tags/SVD/"/>
    
  </entry>
  
  <entry>
    <title>C++学习(二)</title>
    <link href="http://github.com/2018/04/14/C++%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <id>http://github.com/2018/04/14/C++学习(二)/</id>
    <published>2018-04-14T15:30:54.000Z</published>
    <updated>2018-04-15T07:21:33.390Z</updated>
    
    <content type="html"><![CDATA[<p><strong>整形溢出和提升</strong></p><p>大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,<br>你觉得输出结果是什么:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> i = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(i)) &#123;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><p>当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因<br>为sizeof操作返回的是一个 size_t类型的无符号数。<br>在C99/C11标准里写道:</p><blockquote><p>“If the operand that has unsigned integer type has rank greater or<br>equal to the rank of the type of the other operand, then the operand<br>with signed integer type is converted to the type of the operand with<br>unsigned integer type.”</p></blockquote><p>在C标准里面 size_t至少是一个 16 位的无符号整数,对于给定的架构 size_t 一般对应long,所以sizeof（int）和size_t至少相等,这就带来了可移植性的问题,C标准没有定义 short, int,long,longlong的大小,只是说明了他们的最小长度,对于 x86_64 架构,long在Linux下是64位,而在64位Windows下是32位。一般的方法是采用固定长度的类型比如定义在C99头文件stdint.h中的uint16_t,int32_t,uint_least16_t,uint_fast16_t等。</p><p>如果 int可以表示原始类型的所有值,那么这个操作数会转换成 int,否则<br>他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536,但是在 16 位系统返回 0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> sum()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint16_t</span> a = <span class="number">65535</span>;</div><div class="line">    <span class="keyword">uint16_t</span> b = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常<br>由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> c = <span class="number">128</span>;</div><div class="line"><span class="keyword">char</span> d = <span class="number">129</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,c,d);</div></pre></td></tr></table></figure></p><hr><p>##内存管理和分配</p><p>malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取<br>决与系统实现。malloc(0)返回一个空指针或者 unique pointer,如果 size 是表达式的运算结果,确保没有整形溢出。</p><blockquote><p>“If the size of the space requested is 0, the behavior is<br>implementation- defined: the value returned shall be either a null<br>pointer or a unique pointer.”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> computed_size;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (elem_size &amp;&amp; num &gt; SIZE_MAX / elem_size) &#123;</div><div class="line">    errno = ENOMEM;</div><div class="line">    err(<span class="number">1</span>, <span class="string">"overflow"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">computed_size = elem_size*num;</div></pre></td></tr></table></figure></p></blockquote><p>malloc不会给分配的内存初始化，如果要对新分配的内存初始化，可以用calloc代替malloc,一般情况下给序列分配相等大小的元素时,用calloc来代替用表达式计算大小,calloc 会把内存初始化为 0。</p><p>realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间<br>没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。</p><blockquote><p>“In case of failure realloc shall return NULL and leave provided memory<br>object intact. Thus it is important not only to check for integer<br>overflow of size argument, but also to correctly handle object size if<br>realloc fails.”</p></blockquote><p>下面这段代码可以带你领会malloc,calloc，realloc,free的用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_OK            0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_NULL_ERROR    1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_SIZE_ERROR    2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_ALLOC_ERROR   3</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> *data;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc, <span class="keyword">size_t</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vc-&gt;data = <span class="number">0</span>;</div><div class="line">    vc-&gt;size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* check for integer and SIZE_MAX overflow */</span></div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || SIZE_MAX / num &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</div><div class="line">        errno = ENOMEM;</div><div class="line">        <span class="keyword">return</span> VECTOR_SIZE_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vc-&gt;data = <span class="built_in">calloc</span>(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">    <span class="comment">/* calloc faild */</span></div><div class="line">    <span class="keyword">if</span> (vc-&gt;data == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vc-&gt;size = num * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    <span class="keyword">return</span> VECTOR_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">grow_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *newptr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> newsize;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* check for integer and SIZE_MAX overflow */</span></div><div class="line">    <span class="keyword">if</span> (vc-&gt;size == <span class="number">0</span> || SIZE_MAX / <span class="number">2</span> &lt; vc-&gt;size) &#123;</div><div class="line">        errno = ENOMEM;</div><div class="line">        <span class="keyword">return</span> VECTOR_SIZE_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newsize = vc-&gt;size * <span class="number">2</span>;</div><div class="line"></div><div class="line">    newptr = <span class="built_in">realloc</span>(vc-&gt;data, newsize);</div><div class="line"></div><div class="line">    <span class="comment">/* realloc faild; vector stays intact size was not changed */</span></div><div class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* upon success; update new address and size */</span></div><div class="line">    vc-&gt;data = newptr;</div><div class="line">    vc-&gt;size = newsize;</div><div class="line">    <span class="keyword">return</span> VECTOR_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p>##避免重大错误</p><ol><li><p>使用未初始化的变量，<br>C语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和C++不同，C++保证所有变量在使用之前都得到初始化，Java<strong>尽量保证</strong>变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。</p></li><li><p>free错误<br>对空指针调用 free,对不是由 malloc family 函数分配的指针调用 free,或者对<br>已经调用 free 的指针再次调用 free。<br>一开始初始化指针为NULL可以减少错误,GCC和Clang编译器有-Wuninitialized 选项来对未初始化的变量显示警告信息,另外不要将同一个指针用于静态变量和动态变量。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;     <span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</div><div class="line">&gt;     <span class="function"><span class="keyword">void</span> <span class="title">nullfree</span><span class="params">(<span class="keyword">void</span> **pptr)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">void</span> *ptr = *pptr;</div><div class="line">&gt;         assert(ptr != <span class="literal">NULL</span>)</div><div class="line">&gt;         <span class="built_in">free</span>(ptr);</div><div class="line">&gt;         *pptr = <span class="literal">NULL</span>;</div><div class="line">&gt;     &#125;</div></pre></td></tr></table></figure><p>3.对空指针解引用，数组越界访问</p><p>对NULL指针或者free’d内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如Java里的array就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中cost is terrible。</p><p>4.违反类型规则</p><p>把int×指针cast成float×，然后对它解引用，在C里面会引发undefined behavior，C规定这种类型的转换需要使用memset，C++里面有个reinterpret_cast函数用于无关类型之间的转换，reinterpret_cast <new_type> (expression)</new_type></p><hr><p>##防止内存泄漏</p><p>内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用free来释放内存，常用的集中方法如下：</p><ol><li><p>在程序启动的时候分配<br>在程序启动的时候分配需要的heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。</p></li><li><p>使用变长数组（VLA）<br>如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字C标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大VLA内存是SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。</p></li><li><p>使用引用计数<br>引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加1,每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REF_OBJ 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ERROR -1</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span>&#123;</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">uint16_t</span> count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> <span class="title">references</span>[<span class="title">MAX_REF_OBJ</span>];</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> reference_count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/* create memory object and return handle */</span></div><div class="line"><span class="keyword">uint16_t</span> create(<span class="keyword">size_t</span> size)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reference_count &gt;= MAX_REF_OBJ)</div><div class="line">        <span class="keyword">return</span> RC_ERROR;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (size)&#123;</div><div class="line">  <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)&#123;</div><div class="line">    references[reference_count].ptr = ptr;</div><div class="line">    references[reference_count].count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> reference_count++;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> RC_ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* get memory object and increment reference counter */</span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">retain</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</div><div class="line">    references[handle].count++;</div><div class="line">    <span class="keyword">return</span> references[handle].ptr;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* decrement reference counter */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"release\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> *<span class="title">object</span> = &amp;<span class="title">references</span>[<span class="title">handle</span>];</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (object-&gt;count &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"released\n"</span>);</div><div class="line">    <span class="built_in">free</span>(object-&gt;ptr);</div><div class="line">    reference_count--;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"decremented\n"</span>);</div><div class="line">    object-&gt;count--;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>C++标准库有个auto_ptr智能指针，能够自动释放指针所指对象的内存，C++ boost库有个boost：：shared_ptr智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：</p><blockquote><p>“Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// Basic useage</span></div><div class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1); <span class="comment">// or p2 = p1;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    *p1 = <span class="number">999</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2: "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    p2.reset();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 4.内存池，有利于减少内存碎片，看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_pool_t</span>&#123;</span></div><div class="line"><span class="keyword">void</span>* ptr;<span class="comment">//指向内存池起始地址</span></div><div class="line"><span class="keyword">size_t</span> size;<span class="comment">//内存池大小</span></div><div class="line"><span class="keyword">size_t</span> used;<span class="comment">//已用内存大小</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//create memory pool</span></div><div class="line"><span class="function">struct mem_pool_t* <span class="title">create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</div><div class="line"><span class="keyword">mem_pool_t</span>* pool=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(struct <span class="keyword">men_pool_t</span>));</div><div class="line"><span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</div><div class="line"><span class="keyword">void</span>* mem=<span class="built_in">calloc</span>(<span class="number">1</span>,size);</div><div class="line"><span class="keyword">if</span>(mem!=<span class="literal">NULL</span>)&#123;</div><div class="line">pool-&gt;ptr=mem;</div><div class="line">pool-&gt;size=size;</div><div class="line">pool-&gt;used=<span class="number">0</span>;</div><div class="line"><span class="keyword">return</span> pool;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//allocate memory from pool</span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pool_alloc</span><span class="params">(<span class="keyword">mem_pool_t</span>* pool,<span class="keyword">size_t</span> size)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pool=<span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">size_t</span> bytes_left=pool-&gt;size-pool-&gt;used;</div><div class="line"><span class="keyword">if</span>(size&amp;&amp;size&lt;=bytes_left)&#123;</div><div class="line">    <span class="keyword">void</span>* mem=pool-&gt;ptr+pool-&gt;used;</div><div class="line">    pool-&gt;used+=size;</div><div class="line">    <span class="keyword">return</span> mem;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>；</div><div class="line">&#125;</div><div class="line"></div><div class="line">／／release memory of the pool</div><div class="line"><span class="keyword">void</span> pool_free(<span class="keyword">mem_pool_t</span>* pool)&#123;</div><div class="line"><span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</div><div class="line"><span class="built_in">free</span>(pool-&gt;ptr);</div><div class="line"><span class="built_in">free</span>(pool);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 5.垃圾回收机制<br> 引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是MARK AND SWEEP算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。<br>    Java采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA的垃圾回收和C++的析构函数又不一样，C++保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而JAVA不能保证对象一定被析构。</p><hr><p>##指针和数组</p><p>我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是const的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个const左值，指向地一个元素的const指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。</p><p>但是也有例外，什么情况下数组名不是一个指针呢？<br>1.当它是sizeof操作符的操作数时，返回数组占的内存字节数<br>2.当它是取地址操作&amp;的操作数时，返回一个数组的地址</p><p>看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">short</span> *pa;</div><div class="line"><span class="keyword">short</span> (*px)[];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    pa = a;</div><div class="line">    px = &amp;a;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"a:%p; pa:%p; px:%p\n"</span>, a, pa, px);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"a[1]:%i; pa[1]:%i (*px)[1]:%i\n"</span>, a[<span class="number">1</span>], pa[<span class="number">1</span>],(*px)[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>a是一个short类型数组，pa是一个指向short类型的指针，px呢？<br>px是一个指向数组类型的指针，在a被赋值给pa之前，他的值被转换成一个指向数组第一个元素的指针，下面那个a却没有转换，因为遇到的是&amp;操作符。<br>数组下标a[1]等价于<em>(a+1),和p[1]一样，也指向</em>(p+1)，但是两者还是有区别的，a是一个数组，它实际上存储的是第一个元素的地址，所以数组a是用来定位第一个元素的，而pa不一样，它就是一个指针，不是用来定位的。<br>再比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *a;</div><div class="line">c=&amp;a[<span class="number">0</span>];<span class="comment">//c是指向数组a地一个元素的指针</span></div><div class="line">c=a;<span class="comment">//a自动转换成指向第一个元素的指针，实际上是指针拷贝</span></div><div class="line">b=a;<span class="comment">//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组</span></div><div class="line">a=c;<span class="comment">//非法的，你不能修改const指针的值</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;整形溢出和提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,&lt;br&gt;你觉得输出结果是什么:&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(i)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;OK\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;error\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://github.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法--图算法介绍</title>
    <link href="http://github.com/2018/04/14/%E7%AE%97%E6%B3%95-%E5%9B%BE%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://github.com/2018/04/14/算法-图算法介绍/</id>
    <published>2018-04-14T15:17:46.000Z</published>
    <updated>2018-04-15T07:19:05.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h2><p>图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。</p><p>图的种类：地图，电路图，调度图，事物，网络，程序结构</p><p>图的属性：有V个顶点的图最多有V*（V-1）/2条边<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph1.jpg" alt=""><br><a id="more"></a><br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph2.jpg" alt=""></p><h3 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h3><p>邻接矩阵是一个元素为bool值的V<em>V矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为V</em>V，当图是稠密时，邻接矩阵是比较合适的表达方法。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph3.jpg" alt=""></p><h3 id="邻接表的表示"><a href="#邻接表的表示" class="headerlink" title="邻接表的表示"></a>邻接表的表示</h3><p>对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph4.jpg" alt=""></p><hr><hr><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="深度优先搜索介绍"><a href="#深度优先搜索介绍" class="headerlink" title="深度优先搜索介绍"></a>深度优先搜索介绍</h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="深度优先搜索图解"><a href="#深度优先搜索图解" class="headerlink" title="深度优先搜索图解"></a>深度优先搜索图解</h3><h4 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph5.jpg" alt=""><br>对上面的图G1进行深度优先遍历，从顶点A开始。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph6.jpg" alt=""></p><ul><li>第1步：访问A。</li><li><p>第2步：访问(A的邻接点)C。</p><p> 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。</p></li><li><p>第3步：访问(C的邻接点)B。</p><p> 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。</p></li><li><p>第4步：访问(C的邻接点)D。</p><p> 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。</p></li><li><p>第5步：访问(A的邻接点)F。</p><p> 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。</p></li><li><p>第6步：访问(F的邻接点)G。</p></li><li><p>第7步：访问(G的邻接点)E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</p><h4 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph7.jpg" alt=""><br>对上面的图G2进行深度优先遍历，从顶点A开始。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph8.jpg" alt=""></p><ul><li>第1步：访问A。</li><li><p>第2步：访问B。</p><p> 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。</p></li><li><p>第3步：访问C。</p><p> 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。</p></li><li><p>第4步：访问E。</p><p> 接下来访问C的出边的另一个顶点，即顶点E。</p></li><li><p>第5步：访问D。</p></li></ul><pre><code>接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。</code></pre><ul><li><p>第6步：访问F。</p><p> 接下应该回溯”访问A的出边的另一个顶点F”。</p></li><li><p>第7步：访问G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</p><hr><hr><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="广度优先搜索介绍"><a href="#广度优先搜索介绍" class="headerlink" title="广度优先搜索介绍"></a>广度优先搜索介绍</h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="广度优先搜索图解"><a href="#广度优先搜索图解" class="headerlink" title="广度优先搜索图解"></a>广度优先搜索图解</h3><h4 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph9.jpg" alt=""></p><ul><li>第1步：访问A。</li><li><p>第2步：依次访问C,D,F。</p><p> 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。</p></li><li><p>第3步：依次访问B,G。</p><p> 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。</p></li><li><p>第4步：访问E。</p><p> 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</p><h4 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph10.jpg" alt=""></p><ul><li>第1步：访问A。</li></ul><ul><li>第2步：访问B。</li><li>第3步：依次访问C,E,F。</li></ul><pre><code>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。</code></pre><ul><li><p>第4步：依次访问D,G。</p><p> 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</p><h2 id="搜索算法的源码"><a href="#搜索算法的源码" class="headerlink" title="搜索算法的源码"></a>搜索算法的源码</h2><p>1.邻接矩阵表示的”无向图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * C++: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @author LippiOuYang</span></div><div class="line"><span class="comment">    * @date 2013/04/19</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MatrixUDG</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keyword">char</span> mVexs[MAX];    <span class="comment">// 顶点集合</span></div><div class="line">        <span class="keyword">int</span> mVexNum;             <span class="comment">// 顶点数</span></div><div class="line">        <span class="keyword">int</span> mEdgNum;             <span class="comment">// 边数</span></div><div class="line">        <span class="keyword">int</span> mMatrix[MAX][MAX];   <span class="comment">// 邻接矩阵</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// 创建图(自己输入数据)</span></div><div class="line">MatrixUDG();</div><div class="line">        <span class="comment">// 创建图(用已提供的矩阵)</span></div><div class="line">        MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</div><div class="line">~MatrixUDG();</div><div class="line"></div><div class="line">        <span class="comment">// 深度优先搜索遍历图</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 打印矩阵队列图</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="comment">// 读取一个输入字符</span></div><div class="line">        <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 返回ch在mMatrix矩阵中的位置</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</div><div class="line">        <span class="comment">// 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">firstVertex</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</div><div class="line">        <span class="comment">// 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">nextVertex</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</div><div class="line">        <span class="comment">// 深度优先搜索遍历图的递归实现</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 创建图(自己输入数据)</span></div><div class="line"><span class="comment"> */</span></div><div class="line">MatrixUDG::MatrixUDG()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> c1, c2;</div><div class="line">    <span class="keyword">int</span> i, p1, p2;</div><div class="line"></div><div class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</div><div class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"顶点"</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</div><div class="line">        mVexs[i] = readChar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"边"</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</div><div class="line">        c1 = readChar();</div><div class="line">        c2 = readChar();</div><div class="line"></div><div class="line">        p1 = getPosition(c1);</div><div class="line">        p2 = getPosition(c2);</div><div class="line">        <span class="keyword">if</span> (p1==<span class="number">-1</span> || p2==<span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid edge!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</div><div class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 创建图(用已提供的矩阵)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 参数说明：</span></div><div class="line"><span class="comment"> *     vexs  -- 顶点数组</span></div><div class="line"><span class="comment"> *     vlen  -- 顶点数组的长度</span></div><div class="line"><span class="comment"> *     edges -- 边数组</span></div><div class="line"><span class="comment"> *     elen  -- 边数组的长度</span></div><div class="line"><span class="comment"> */</span></div><div class="line">MatrixUDG::MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, p1, p2;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></div><div class="line">    mVexNum = vlen;</div><div class="line">    mEdgNum = elen;</div><div class="line">    <span class="comment">// 初始化"顶点"</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        mVexs[i] = vexs[i];</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"边"</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></div><div class="line">        p1 = getPosition(edges[i][<span class="number">0</span>]);</div><div class="line">        p2 = getPosition(edges[i][<span class="number">1</span>]);</div><div class="line"></div><div class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</div><div class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 析构函数</span></div><div class="line"><span class="comment"> */</span></div><div class="line">MatrixUDG::~MatrixUDG()</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 返回ch在mMatrix矩阵中的位置</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> MatrixUDG::getPosition(<span class="keyword">char</span> ch)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</div><div class="line">        <span class="keyword">if</span>(mVexs[i]==ch)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 读取一个输入字符</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">char</span> MatrixUDG::readChar()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> ch;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</div><div class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> MatrixUDG::firstVertex(<span class="keyword">int</span> v)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>))</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> MatrixUDG::nextVertex(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>) || w&lt;<span class="number">0</span> || w&gt;(mVexNum<span class="number">-1</span>))</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = w + <span class="number">1</span>; i &lt; mVexNum; i++)</div><div class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> MatrixUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> w;</div><div class="line"></div><div class="line">    visited[i] = <span class="number">1</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走</span></div><div class="line">    <span class="keyword">for</span> (w = firstVertex(i); w &gt;= <span class="number">0</span>; w = nextVertex(i, w))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!visited[w])</div><div class="line">            DFS(w, visited);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 深度优先搜索遍历图</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> MatrixUDG::DFS()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        visited[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//printf("\n== LOOP(%d)\n", i);</span></div><div class="line">        <span class="keyword">if</span> (!visited[i])</div><div class="line">            DFS(i, visited);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> MatrixUDG::BFS()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></div><div class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></div><div class="line">    <span class="keyword">int</span> i, j, k;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        visited[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!visited[i])</div><div class="line">        &#123;</div><div class="line">            visited[i] = <span class="number">1</span>;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (head != rear)</div><div class="line">        &#123;</div><div class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></div><div class="line">            <span class="keyword">for</span> (k = firstVertex(j); k &gt;= <span class="number">0</span>; k = nextVertex(j, k)) <span class="comment">//k是为访问的邻接顶点</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (!visited[k])</div><div class="line">                &#123;</div><div class="line">                    visited[k] = <span class="number">1</span>;</div><div class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k] &lt;&lt; <span class="string">" "</span>;</div><div class="line">                    <span class="built_in">queue</span>[rear++] = k;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 打印矩阵队列图</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> MatrixUDG::print()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Martix Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mVexNum; j++)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; mMatrix[i][j] &lt;&lt; <span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</div><div class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;,</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;,</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;,</div><div class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;,</div><div class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;,</div><div class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;,</div><div class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</div><div class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</div><div class="line">    MatrixUDG* pG;</div><div class="line"></div><div class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></div><div class="line">    <span class="comment">//pG = new MatrixUDG();</span></div><div class="line">    <span class="comment">// 采用已有的"图"</span></div><div class="line">    pG = <span class="keyword">new</span> MatrixUDG(vexs, vlen, edges, elen);</div><div class="line"></div><div class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></div><div class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></div><div class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.邻接表表示的”无向图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * C++: 邻接表表示的"无向图(List Undirected Graph)"</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @author LippiOuYang</span></div><div class="line"><span class="comment"> * @date 2013/04/19</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></div><div class="line"><span class="comment">// 邻接表</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListUDG</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>: <span class="comment">// 内部类</span></div><div class="line">        <span class="comment">// 邻接表中表对应的链表的顶点</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">ENode</span></span></div><div class="line"><span class="class">        &#123;</span></div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="keyword">int</span> ivex;           <span class="comment">// 该边所指向的顶点的位置</span></div><div class="line">                ENode *nextEdge;    <span class="comment">// 指向下一条弧的指针</span></div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 邻接表中表的顶点</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">VNode</span></span></div><div class="line"><span class="class">        &#123;</span></div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="keyword">char</span> data;          <span class="comment">// 顶点信息</span></div><div class="line">                ENode *firstEdge;   <span class="comment">// 指向第一条依附该顶点的弧</span></div><div class="line">        &#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span>: <span class="comment">// 私有成员</span></div><div class="line">        <span class="keyword">int</span> mVexNum;             <span class="comment">// 图的顶点的数目</span></div><div class="line">        <span class="keyword">int</span> mEdgNum;             <span class="comment">// 图的边的数目</span></div><div class="line">        VNode mVexs[MAX];</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// 创建邻接表对应的图(自己输入)</span></div><div class="line">ListUDG();</div><div class="line">        <span class="comment">// 创建邻接表对应的图(用已提供的数据)</span></div><div class="line">        ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</div><div class="line">~ListUDG();</div><div class="line"></div><div class="line">        <span class="comment">// 深度优先搜索遍历图</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 打印邻接表图</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="comment">// 读取一个输入字符</span></div><div class="line">        <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">// 返回ch的位置</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</div><div class="line">        <span class="comment">// 深度优先搜索遍历图的递归实现</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</div><div class="line">        <span class="comment">// 将node节点链接到list的最后</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(ENode *<span class="built_in">list</span>, ENode *node)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 创建邻接表对应的图(自己输入)</span></div><div class="line"><span class="comment"> */</span></div><div class="line">ListUDG::ListUDG()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> c1, c2;</div><div class="line">    <span class="keyword">int</span> v, e;</div><div class="line">    <span class="keyword">int</span> i, p1, p2;</div><div class="line">    ENode *node1, *node2;</div><div class="line"></div><div class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</div><div class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</div><div class="line">        mVexs[i].data = readChar();</div><div class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"邻接表"的边</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</div><div class="line">        c1 = readChar();</div><div class="line">        c2 = readChar();</div><div class="line"></div><div class="line">        p1 = getPosition(c1);</div><div class="line">        p2 = getPosition(c2);</div><div class="line">        <span class="comment">// 初始化node1</span></div><div class="line">        node1 = <span class="keyword">new</span> ENode();</div><div class="line">        node1-&gt;ivex = p2;</div><div class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></div><div class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</div><div class="line">          mVexs[p1].firstEdge = node1;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkLast(mVexs[p1].firstEdge, node1);</div><div class="line">        <span class="comment">// 初始化node2</span></div><div class="line">        node2 = <span class="keyword">new</span> ENode();</div><div class="line">        node2-&gt;ivex = p1;</div><div class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></div><div class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</div><div class="line">          mVexs[p2].firstEdge = node2;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkLast(mVexs[p2].firstEdge, node2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 创建邻接表对应的图(用已提供的数据)</span></div><div class="line"><span class="comment"> */</span></div><div class="line">ListUDG::ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> c1, c2;</div><div class="line">    <span class="keyword">int</span> i, p1, p2;</div><div class="line">    ENode *node1, *node2;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></div><div class="line">    mVexNum = vlen;</div><div class="line">    mEdgNum = elen;</div><div class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        mVexs[i].data = vexs[i];</div><div class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化"邻接表"的边</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></div><div class="line">        c1 = edges[i][<span class="number">0</span>];</div><div class="line">        c2 = edges[i][<span class="number">1</span>];</div><div class="line"></div><div class="line">        p1 = getPosition(c1);</div><div class="line">        p2 = getPosition(c2);</div><div class="line">        <span class="comment">// 初始化node1</span></div><div class="line">        node1 = <span class="keyword">new</span> ENode();</div><div class="line">        node1-&gt;ivex = p2;</div><div class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></div><div class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</div><div class="line">          mVexs[p1].firstEdge = node1;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkLast(mVexs[p1].firstEdge, node1);</div><div class="line">        <span class="comment">// 初始化node2</span></div><div class="line">        node2 = <span class="keyword">new</span> ENode();</div><div class="line">        node2-&gt;ivex = p1;</div><div class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></div><div class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</div><div class="line">          mVexs[p2].firstEdge = node2;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkLast(mVexs[p2].firstEdge, node2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 析构函数</span></div><div class="line"><span class="comment"> */</span></div><div class="line">ListUDG::~ListUDG()</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 将node节点链接到list的最后</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> ListUDG::linkLast(ENode *<span class="built_in">list</span>, ENode *node)</div><div class="line">&#123;</div><div class="line">    ENode *p = <span class="built_in">list</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p-&gt;nextEdge)</div><div class="line">        p = p-&gt;nextEdge;</div><div class="line">    p-&gt;nextEdge = node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 返回ch的位置</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> ListUDG::getPosition(<span class="keyword">char</span> ch)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</div><div class="line">        <span class="keyword">if</span>(mVexs[i].data==ch)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 读取一个输入字符</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">char</span> ListUDG::readChar()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> ch;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</div><div class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> ListUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</div><div class="line">&#123;</div><div class="line">    ENode *node;</div><div class="line"></div><div class="line">    visited[i] = <span class="number">1</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">    node = mVexs[i].firstEdge;</div><div class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!visited[node-&gt;ivex])</div><div class="line">            DFS(node-&gt;ivex, visited);</div><div class="line">        node = node-&gt;nextEdge;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 深度优先搜索遍历图</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> ListUDG::DFS()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        visited[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!visited[i])</div><div class="line">            DFS(i, visited);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> ListUDG::BFS()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></div><div class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></div><div class="line">    <span class="keyword">int</span> i, j, k;</div><div class="line">    ENode *node;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">        visited[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!visited[i])</div><div class="line">        &#123;</div><div class="line">            visited[i] = <span class="number">1</span>;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (head != rear)</div><div class="line">        &#123;</div><div class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></div><div class="line">            node = mVexs[j].firstEdge;</div><div class="line">            <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                k = node-&gt;ivex;</div><div class="line">                <span class="keyword">if</span> (!visited[k])</div><div class="line">                &#123;</div><div class="line">                    visited[k] = <span class="number">1</span>;</div><div class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">                    <span class="built_in">queue</span>[rear++] = k;</div><div class="line">                &#125;</div><div class="line">                node = node-&gt;nextEdge;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 打印邻接表图</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> ListUDG::print()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    ENode *node;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"List Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">"): "</span>;</div><div class="line">        node = mVexs[i].firstEdge;</div><div class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;ivex &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; <span class="string">") "</span>;</div><div class="line">            node = node-&gt;nextEdge;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</div><div class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;,</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;,</div><div class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;,</div><div class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;,</div><div class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;,</div><div class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;,</div><div class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</div><div class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</div><div class="line">    ListUDG* pG;</div><div class="line"></div><div class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></div><div class="line">    <span class="comment">//pG = new ListUDG();</span></div><div class="line">    <span class="comment">// 采用已有的"图"</span></div><div class="line">    pG = <span class="keyword">new</span> ListUDG(vexs, vlen, edges, elen);</div><div class="line"></div><div class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></div><div class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></div><div class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p> 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p> 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li>(1)<br>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</li><li>(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</li><li>(3)<br>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</li><li>(4) 重复步骤(2)和(3)，直到遍历完所有顶点。</li></ul><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>5.3迪杰斯特拉算法图解<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph11.jpg" alt=""><br>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。<br><img src="https://www.ezlippi.com/images/images/githubpages/graph/graph12.jpg" alt=""></p><ul><li>初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！</li></ul><ul><li><p>第1步：将顶点D加入到S中。</p><p> 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。</p></li><li><p>第2步：将顶点C加入到S中。</p><p> 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br> 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p></li><li><p>第3步：将顶点E加入到S中。</p><p> 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br> 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p></li><li><p>第4步：将顶点F加入到S中。</p></li></ul><pre><code>此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</code></pre><ul><li><p>第5步：将顶点G加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p></li><li><p>第6步：将顶点B加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p></li><li><p>第7步：将顶点A加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p></li></ul><p>此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr><p>本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明，</p><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><pre><code>// 邻接矩阵typedef struct _graph{    char vexs[MAX];       // 顶点集合    int vexnum;           // 顶点数    int edgnum;           // 边数    int matrix[MAX][MAX]; // 邻接矩阵}Graph, *PGraph;// 边的结构体typedef struct _EdgeData{    char start; // 边的起点    char end;   // 边的终点    int weight; // 边的权重}EData;</code></pre><p>Graph是邻接矩阵对应的结构体。<br>vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。<br>EData是邻接矩阵边对应的结构体。</p><h4 id="迪杰斯特拉算法-1"><a href="#迪杰斯特拉算法-1" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Dijkstra最短路径。</span></div><div class="line"><span class="comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 参数说明：</span></div><div class="line"><span class="comment"> *        G -- 图</span></div><div class="line"><span class="comment"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span></div><div class="line"><span class="comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span></div><div class="line"><span class="comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> vs, <span class="keyword">int</span> prev[], <span class="keyword">int</span> dist[])</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> i,j,k;</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">int</span> tmp;</div><div class="line">    <span class="keyword">int</span> flag[MAX];      <span class="comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</div><div class="line">    &#123;</div><div class="line">        flag[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的最短路径还没获取到。</span></div><div class="line"></div><div class="line"></div><div class="line">           prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></div><div class="line">            dist[i] = G.matrix[vs][i];<span class="comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 对"顶点vs"自身进行</span></div><div class="line"></div><div class="line">    初始化</div><div class="line">    flag[vs] = <span class="number">1</span>;</div><div class="line">    dist[vs] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; i++)</div><div class="line">    &#123;</div><div class="line">    <span class="comment">// 寻找当前最小的路径；</span></div><div class="line">    <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></div><div class="line">    min = INF;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (flag[j]==<span class="number">0</span> &amp;&amp; dist[j]&lt;min)</div><div class="line">        &#123;</div><div class="line">            min = dist[j];</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 标记"顶点k"为已经获取到最短路径</span></div><div class="line">    flag[k] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 修正当前最短路径和前驱顶点</span></div><div class="line">    <span class="comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</div><div class="line">    &#123;</div><div class="line">        tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); <span class="comment">// 防止溢出</span></div><div class="line">        <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; (tmp  &lt; dist[j]) )</div><div class="line">        &#123;</div><div class="line">            dist[j] = tmp;</div><div class="line">            prev[j] = k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"dijkstra(%c): \n"</span>, G.vexs[vs]);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"  shortest(%c, %c)=%d\n"</span>, G.vexs[vs], G.vexs[i], dist[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的定义：&quot;&gt;&lt;a href=&quot;#图的定义：&quot; class=&quot;headerlink&quot; title=&quot;图的定义：&quot;&gt;&lt;/a&gt;图的定义：&lt;/h2&gt;&lt;p&gt;图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。&lt;/p&gt;
&lt;p&gt;图的种类：地图，电路图，调度图，事物，网络，程序结构&lt;/p&gt;
&lt;p&gt;图的属性：有V个顶点的图最多有V*（V-1）/2条边&lt;br&gt;&lt;img src=&quot;https://www.ezlippi.com/images/images/githubpages/graph/graph1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图算法" scheme="http://github.com/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习（五）常用命令</title>
    <link href="http://github.com/2018/04/14/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://github.com/2018/04/14/Linux学习（五）常用命令/</id>
    <published>2018-04-14T15:08:43.000Z</published>
    <updated>2018-04-14T15:09:39.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h1><p>很多时候我们通过<code>cat</code>命令来查看文件内容，它会将文件的所有内容显示出来。当然，<code>cat</code>也可以通过管道接收数据，它主要完成的是将从管道接收的输入导到输出。</p><h1 id="more跟less命令"><a href="#more跟less命令" class="headerlink" title="more跟less命令"></a>more跟less命令</h1><p>有时候用<code>cat</code>命令来显示一个较大的文件并不方便，整个文件内容一次性显示出来简直就是刷屏了。如果需要一页页的显示内容，可以使用<code>more</code>或者<code>less</code>命令，这两个命令会以分页的形式显示文件内容，至于使用哪个命令完全看个人习惯了。此外，这两个命令不仅可以分页显示，而且在分页模式下，你可以用快捷键方便的浏览及搜索：</p><pre><code>* 按`d`下翻页* 按空格下翻页* 按回车下移一行* 按`/`进入搜索模式，输入要搜索的关键字，按回车搜索。* 按`n`搜索下一个* 按`q`退出查看</code></pre><a id="more"></a><h1 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h1><p><code>tee</code>命令一般从管道接收数据，这点与<code>cat</code>类似，将stdin导到stdout。不同的是，<code>tee</code>同时还可以指定一个文件作为输出。这点非常有用，有时候我们想一般看到命令的输出，同时又希望将输出保存到文件中，这时候用<code>tee</code>最为合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># date | tee time.log</div><div class="line">Mon Nov 20 14:05:02 EST 2017</div><div class="line"># cat time.log</div><div class="line">Mon Nov 20 14:05:02 EST 2017</div></pre></td></tr></table></figure><h1 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h1><p><code>date</code>命令用来显示时间跟时区，比较常见的用法有：</p><ul><li><p>默认显示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># date</div><div class="line">Sun Nov 19 20:08:21 EST 2017</div><div class="line"># date -u</div><div class="line">Mon Nov 20 01:08:28 UTC 2017</div></pre></td></tr></table></figure><p>  其中，<code>-u</code>参数表示显示UTC标准时间，即时区为0的时间。</p></li><li><p>指定显示格式</p><p>  除了默认输出，我们也可以指定显示的格式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># date +&apos;%A %d-%m-%Y UTC %:z&apos;</div><div class="line">Sunday 19-11-2017 UTC -05:00</div></pre></td></tr></table></figure><p>  <code>date</code>支持非常多元化的格式，具体可以参考<a href="https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/" target="_blank" rel="external">这里</a>。</p></li><li><p>显示当前时间的秒数</p><p>  通常，在计算当前时间的秒数的时候，我们通常会以<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="external">Unix Epoch Time</a>为基准，用<code>date</code>命令可以非常方便的显示当前时间的秒数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># date +%s</div><div class="line">1511141040</div><div class="line"># date +%s --date=&apos;2017/11/19 09:56:00&apos;</div><div class="line">1511103360</div></pre></td></tr></table></figure><p>  其中，也可以通过参数<code>--date</code>指定时间来计算。反过来，如果我们知道了时间的秒数，需要显示其相对于Unix Epoch Time的时间，可以这么做：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># date; date +%s</div><div class="line">Mon Nov 20 10:33:07 EST 2017</div><div class="line">1511191987</div><div class="line"># date --date=@1511191987</div><div class="line">Mon Nov 20 10:33:07 EST 2017</div></pre></td></tr></table></figure></li><li><p>时间偏移计算</p><p>  有时候需要知道多少天前是什么时间，这时候需要用到时间偏移计算了：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># date --date=&apos;100 seconds ago&apos;</div><div class="line">Sun Nov 19 20:35:44 EST 2017</div><div class="line"># date --date=&apos;100 hours ago&apos;</div><div class="line">Wed Nov 15 16:37:28 EST 2017</div><div class="line"># date --date=&apos;100 days ago&apos;</div><div class="line">Fri Aug 11 21:37:34 EDT 2017</div></pre></td></tr></table></figure><p>  <code>date</code>命令可以识别多种时间偏移写法，除了示例中的，还有<code>minutes months years</code>等，当然，也可以这样写:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># date --date=&apos;+ 1000 seconds&apos;</div><div class="line">Sun Nov 19 20:56:28 EST 2017</div><div class="line"># date --date=&apos;- 1000 seconds&apos;</div><div class="line">Sun Nov 19 20:23:41 EST 2017</div><div class="line"># date --date=&apos;2017-11-19 00:00:00 + 1000 seconds&apos;</div><div class="line">Sat Nov 18 09:00:01 EST 2017</div></pre></td></tr></table></figure><p>  直接用<code>+</code>或者<code>-</code>表示以后或者以前的时间，也可以指定某个时间点然后偏移。</p></li><li><p>设置时间</p><p>  当然，你也可以通过<code>date</code>命令来设置时间：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># date</div><div class="line">Sun Nov 19 20:44:11 EST 2017</div><div class="line"># date --set=&apos;Sun Nov 19 20:44:30 EST 2017&apos;</div><div class="line">Sun Nov 19 20:44:30 EST 2017</div><div class="line"># date</div><div class="line">Sun Nov 19 20:44:31 EST 2017</div></pre></td></tr></table></figure><p>  其中<code>--set</code>也可以简写为<code>-s</code>，时间格式非常灵活：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># date -s &apos;2017/11/20 10:19:50&apos;</div><div class="line">Mon Nov 20 10:19:50 EST 2017</div></pre></td></tr></table></figure></li></ul><h1 id="cal命令"><a href="#cal命令" class="headerlink" title="cal命令"></a>cal命令</h1><p>我们用<code>date</code>可以显示时间，同时咱们还可以通过<code>cal</code>命令来显示日历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># cal</div><div class="line">    November 2017</div><div class="line">Su Mo Tu We Th Fr Sa</div><div class="line">          1  2  3  4</div><div class="line"> 5  6  7  8  9 10 11</div><div class="line">12 13 14 15 16 17 18</div><div class="line">19 20 21 22 23 24 25</div><div class="line">26 27 28 29 30</div></pre></td></tr></table></figure><p>当然，你也可以指定要显示的日期，比如1949年10月的日历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># cal 10 1949</div><div class="line">    October 1949</div><div class="line">Su Mo Tu We Th Fr Sa</div><div class="line">                   1</div><div class="line"> 2  3  4  5  6  7  8</div><div class="line"> 9 10 11 12 13 14 15</div><div class="line">16 17 18 19 20 21 22</div><div class="line">23 24 25 26 27 28 29</div><div class="line">30 31</div></pre></td></tr></table></figure><h1 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h1><p>有时候我们需要知道一个命令运行了多少时间，这时候我们可以用<code>time</code>命令来计时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># time sleep 1</div><div class="line"></div><div class="line">real0m1.018s</div><div class="line">user0m0.001s</div><div class="line">sys  0m0.002s</div></pre></td></tr></table></figure><p>其中<code>sleep 1</code>用来睡眠1秒，<code>real</code>表示实际用了多少时间，<code>user</code>表示在用户态花了多少时间，<code>sys</code>则表示在内核花了多少时间。详细可以参考<a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1" target="_blank" rel="external">这篇问答</a>。</p><h1 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h1><p><code>wc</code>命令是<code>Word Count</code>的简称，顾名思义就是用来统计单词的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out</div><div class="line"># cat test.log | wc -w</div><div class="line">14</div></pre></td></tr></table></figure><p>参数<code>-w</code>表示统计单词数，这里的单词实际上指的是被空格分开的字符串。下面列举出<code>wc</code>命令的有关参数：</p><p>|——+————————|<br>| 参数 | 说明                   |<br>|——+————————|<br>| -w   | 统计多少单词           |<br>| -l   | 统计多少行             |<br>| -c   | 统计有多少个字节       |<br>| -m   | 统计有多少个字符       |<br>| -L   | 统计长度最长的行的长度 |<br>|——+————————|</p><p>注意，这里的字节跟字符的差别，在英文中基本上是一样的，但是在多字节语言中，其意义就不一样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo &apos;你好&apos; | wc -c</div><div class="line">7</div><div class="line"># echo &apos;你好&apos; | wc -m</div><div class="line">3</div></pre></td></tr></table></figure><h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><p><code>find</code>命令用来查找文件或目录，这又是一个非常强大的且常用的命令，这里只介绍几种常见的用法：</p><ul><li><p>根据名字查找</p><p>  这是基本且常见的用法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># find . -name &quot;test*&quot;</div><div class="line">./test.log</div><div class="line">./test2</div></pre></td></tr></table></figure><p>  示例中表示在当前目录（用<code>.</code>表示）下包括其子目录，查找文件名以<code>test</code>开头的文件或者目录。默认情况下，<code>find</code>命令是大小写敏感的，如果需要忽略大小写，则可以改用参数<code>-iname</code>。</p></li><li><p>根据路径查找</p><p>  <code>-name</code>参数会根据名字查找，如果需要对路径进行匹配查找，则可以用<code>-path</code>参数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># find . -path &quot;./tmp/*&quot;</div><div class="line">./tmp/Test1</div><div class="line">./tmp/test2</div><div class="line">./tmp/test.log</div><div class="line">./tmp/test.cpp</div><div class="line">./tmp/time.log</div></pre></td></tr></table></figure></li><li><p>根据类型查找</p><p>  可以根据类型查找文件：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># find . -type f</div><div class="line">./Test1</div><div class="line">./test.log</div><div class="line">./test2</div></pre></td></tr></table></figure><p>  当然，也可以同时根据类型跟文件名一起查找：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># find . -type f -name &quot;test*&quot;</div><div class="line">./test.log</div><div class="line">./test2</div></pre></td></tr></table></figure><p>  <code>f</code>表示文件，如果是查找目录的话则用<code>d</code>。</p></li><li><p>根据时间查找</p><p>  <code>find</code>命令还可以根据时间来查找文件目录，其中一个用法如下：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -newer base_file</div></pre></td></tr></table></figure><p>  表示在当前目录下查找比<code>base_file</code>文件更新的文件或者目录。此外，<code>find</code>还可以根据文件的<a href="https://www.unixtutorial.org/2008/04/atime-ctime-mtime-in-unix-filesystems/" target="_blank" rel="external">atime, ctime, mtime</a>来查找文件，如下，根据修改时间来查找：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># date</div><div class="line">Fri Nov 17 20:34:52 EST 2017</div><div class="line"># ll</div><div class="line">total 20</div><div class="line">drwxr-xr-x.  2 root root   45 Nov 17 02:46 ./</div><div class="line">dr-xr-x---. 48 root root 8192 Nov 17 02:46 ../</div><div class="line">-rw-r--r--.  1 root root    0 Nov 16 00:17 Test1</div><div class="line">-rw-r--r--.  1 root root   34 Nov 17 02:46 test2</div><div class="line">-rw-r--r--.  1 root root  102 Nov 17 00:30 test.log</div><div class="line"># find . -mtime -1</div><div class="line">.</div><div class="line">./test.log</div><div class="line">./test2</div></pre></td></tr></table></figure><p>  其中<code>-mtime</code>表示根据修改时间查找，<code>-1</code>表示最近一天。<code>find</code>支持的时间查找总结如下：</p><p>  |——–+———————————————-|<br>  | 参数   | 说明                                         |<br>  |——–+———————————————-|<br>  | -mtime | 根据修改时间，也就是<code>ls -l</code>显示的时间        |<br>  | -atime | 根据访问时间，也就是<code>ls -lu</code>显示的时间       |<br>  | -ctime | 根据状态改变的时间，也就是<code>ls -lc</code>显示的时间 |<br>  |——–+———————————————-|</p><p>  时间值的表示说明：基准<code>+0</code>表示一天前，<code>-1.5</code>表示最近1.5天，<code>+1.5</code>表示2.5天前</p></li><li><p>逻辑查找</p><p>  <code>find</code>支持与或非逻辑的查找，比如查找所有C++的源文件，实际上需要找出后缀为<code>.cpp</code>跟<code>.h</code>的文件，需要用到<code>find</code>的逻辑或的查找：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">"*.cpp"</span> -o -name <span class="string">"*.h"</span></div></pre></td></tr></table></figure><p>  其中<code>-o</code>是<code>-or</code>的缩写，用来表示逻辑或的关系，而<code>-name &quot;*.cpp&quot;</code>与<code>-name &quot;*.h&quot;</code>为表达式，构成了<code>EXP1 or EXP2</code>的关系，只要文件或者目录满足其中一个表达式就会输出。<code>find</code>支持的逻辑关系如下：</p><p>  |——+——+——————————————————————–|<br>  | 逻辑 | 参数 | 说明                                                               |<br>  |——+——+——————————————————————–|<br>  | 与   | -a   | <code>-and</code>的缩写，逻辑与的关系，如<code>find . -type f -a -name &quot;*.log&quot;</code>    |<br>  | 或   | -o   | <code>-or</code>的缩写，逻辑或的关系, 如<code>find . -name &quot;*.cpp&quot; -o -name &quot;*.h&quot;</code> |<br>  | 非   | !    | <code>-not</code>的缩写，逻辑非的关系, 如<code>find . ! -name &quot;*.cpp&quot;</code>             |<br>  |——+——+——————————————————————–|</p></li></ul><p>此外，<code>find</code>命令还有一个非常重要且常见的用法，就是在找到文件后执行某个命令，改用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name "*.log" -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure><p>表示删除当前目录包括子目录中以<code>.log</code>为后缀的所有文件。其中，<code>-exec</code>表示在找到后需要执行命令，而命令为<code>rm {} \;</code>，实际上此命令就是一般的<code>shell</code>命令，其中<code>{}</code>用来指代找到的文件或目录，这里<code>;</code>必须转义，因为需要传递给<code>find</code>本身，如果不转义，则会直接被<code>shell</code>解析使用了。每找到一个文件或目录，都会执行指定的命令，其中<code>{}</code>部分以文件路径替代。如果需要只执行一次命令，而把所有找到的文件作为参数传递给该命令，则需要用<code>+</code>替代<code>\;</code>，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name "*.log" -exec rm &#123;&#125; +</div></pre></td></tr></table></figure><p>假定找到的文件有<code>test.log</code>，<code>test1.log</code>，用<code>\;</code>的方式相当于执行两次：<code>rm test.log</code>跟<code>rm test1.log</code>；如果使用<code>+</code>则只有一次命令<code>rm test.log test1.log</code>。</p><h1 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h1><p>顾名思义，这个命令就是用来排序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># head -n 5 /etc/passwd | sort</div><div class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div><div class="line">root:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure><p>默认情况下，<code>sort</code>命令以字典顺序对每行进行排序，如果不带参数，会将整行作为一个字符串进行比较。当然，你也可以指定以第几列进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># head -n 5 /etc/passwd | tr : &quot; &quot; | sort -k 3</div><div class="line">root x 0 0 root /root /bin/bash</div><div class="line">bin x 1 1 bin /bin /sbin/nologin</div><div class="line">daemon x 2 2 daemon /sbin /sbin/nologin</div><div class="line">adm x 3 4 adm /var/adm /sbin/nologin</div><div class="line">lp x 4 7 lp /var/spool/lpd /sbin/nologin</div></pre></td></tr></table></figure><p>这里先将<code>:</code>换成空格（关于<code>tr</code>命令，请参照本文关于<code>tr</code>命令的章节），然后以<code>-k</code>为参数，指定以第三列进行排序。下面列举其常用的一些参数：</p><p>|——+————————————————————————————————————|<br>| 参数 | 说明                                                                                                       |<br>|——+————————————————————————————————————|<br>| -k   | 以第几列排序，列以空格为分隔                                                                               |<br>| -r   | 默认<code>sort</code>以升序输出，<code>-r</code>参数则可以以降序输出                                                             |<br>| -n   | 在指定第几列的时候，可以强制<code>sort</code>把列的值以数字值进行排序，如下面的例子                                   |<br>| -t   | 默认情况下认为列是以空格为分隔，<code>-t</code>参数则可以指定分隔符，这样，上面的例子其实可以直接写成<code>sort -t : -k 3</code> |<br>| -f   | 忽略大小写                                                                                                 |<br>| -u   | 如果排序后出现重复的行，加上这个参数将只显示一行                                                           |<br>|——+————————————————————————————————————|</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># cat test2</div><div class="line">10</div><div class="line">3</div><div class="line">5</div><div class="line">3</div><div class="line"># cat test2 | sort</div><div class="line">10</div><div class="line">3</div><div class="line">3</div><div class="line">5</div><div class="line"># cat test2 | sort -n</div><div class="line">3</div><div class="line">3</div><div class="line">5</div><div class="line">10</div><div class="line"># cat test2 | sort -n -u</div><div class="line">3</div><div class="line">5</div><div class="line">10</div></pre></td></tr></table></figure><h1 id="uniq命令"><a href="#uniq命令" class="headerlink" title="uniq命令"></a>uniq命令</h1><p><code>uniq</code>是<code>unique</code>的简写，用来消除<code>sort</code>排序后重复的行，即相当于<code>sort</code>命令中的<code>-u</code>参数。但是，<code>uniq</code>不仅可以消除重复行，它还可以显示分别重复了多少行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test2 | sort -n | uniq -c</div><div class="line">      2 3</div><div class="line">      1 5</div><div class="line">      1 10</div></pre></td></tr></table></figure><p>还有些常用的参数如下：</p><p>|——+————————————————————|<br>| 参数 | 说明                                                       |<br>|——+————————————————————|<br>| -i   | 忽略大小写                                                 |<br>| -d   | 只打印有重复的行，每组一个，如果要打印组内所有的，则用<code>-D</code> |<br>| -u   | 只打印没有重复的行                                         |<br>| -f   | 比较的时候，忽略前面的N列                                  |<br>| -s   | 比较的时候，忽略前面的N个字符                              |<br>|——+————————————————————|</p><h1 id="od命令"><a href="#od命令" class="headerlink" title="od命令"></a>od命令</h1><p><code>od</code>可以用来显示二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat test2</div><div class="line">abcdefg</div><div class="line">1234567</div><div class="line"># od -t x1 test2</div><div class="line">0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a</div><div class="line">0000020</div></pre></td></tr></table></figure><p>当然，也可以直接显示字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># od -c test2</div><div class="line">0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n</div><div class="line">0000020</div></pre></td></tr></table></figure><p>当然，如果仅仅只是显示二进制内容，还可以使用<code>hexdump</code>命令了。</p><h1 id="压缩类命令"><a href="#压缩类命令" class="headerlink" title="压缩类命令"></a>压缩类命令</h1><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>在Linux中，用的最多的压缩命令就是<code>tar</code>命令了，在介绍其用法之前，需要清楚几个概念：</p><ul><li><p>存档文件(Archive File)</p><p>  存档文件用来打包多个文件成一个文件，以方便在网络上传输。请注意，打包成的文件并没有被压缩。在Linux或Unix系统中，TAR文件是最为常用的存档文件（通常以<code>.tar</code>为文件后缀）。TAR文件的更多解释可以参考<a href="http://www.bitzipper.com/tar-file.html" target="_blank" rel="external">这里</a>。用<code>tar</code>命令可以生产TAR文件，示例如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar cvf tmp.tar tmp/</div></pre></td></tr></table></figure><p>  具体参数在下面会具体解释，不带任何压缩格式的话，<code>tar</code>命令会生成一个TAR文件。相应的，如果需要解开TAR文件，可以这么做：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xvf tmp.tar</div></pre></td></tr></table></figure></li><li><p>压缩文件(Compressed File)</p><p>  TAR文件是没有被压缩的，大小基本保持不变。如果需要对文件进行压缩，则需要在<code>tar</code>命令中加入压缩格式对应的参数，具体在下面会说明。</p></li></ul><p>下面来详细介绍<code>tar</code>命令的用法，<code>tar</code>的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># tar --help</div><div class="line">Usage: tar [OPTION...] [FILE]...</div></pre></td></tr></table></figure><p><code>tar</code>命令支持非常多的参数，这里列举比较常用的几种使用方式：</p><ul><li><p>压缩文件或目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># tar czvf tmp.tgz tmp/</div><div class="line">tmp/</div><div class="line">tmp/Test1</div><div class="line">tmp/test.log</div><div class="line">tmp/test2</div></pre></td></tr></table></figure><p>  其中，<code>czvf</code>表示参数选项；<code>tmp.tgz</code>表示压缩后的文件名，通常<code>tgz</code>是<code>tar.gz</code>的简写；<code>tmp/</code>表示被压缩的目录。参数的解释如下：</p><p>  |——+————————————————————-|<br>  | 参数 | 说明                                                        |<br>  |——+————————————————————-|<br>  | c    | <code>Create</code>的简写，表示生产压缩文件                            |<br>  | z    | 表示采用<code>gzip</code>的压缩格式，文件后缀通常为<code>.tar.gz</code>或者<code>.tgz</code> |<br>  | v    | 表示显示压缩的过程，会列出所有被压缩的文件                  |<br>  | f    | 指定压缩文件                                                |<br>  |——+————————————————————-|</p><p>  需要注意的是，<code>tar</code>支持不同的压缩格式，除了<code>gzip</code>之外，还有：</p><p>  |———-+———————————————|<br>  | 参数     | 说明                                        |<br>  |———-+———————————————|<br>  | j        | 采用<code>bzip2</code>的压缩格式，文件后缀通常为<code>.bz2</code> |<br>  | <code>--lzip</code> | 采用<code>lzip</code>的压缩格式，文件后缀通常为<code>.lz</code>   |<br>  | <code>--xz</code>   | 采用<code>xz</code>的压缩格式，文件后缀通常为<code>.xz</code>     |<br>  | <code>--lzma</code> | 采用<code>lzma</code>的压缩格式，文件后缀通常为<code>.lzma</code> |<br>  |———-+———————————————|</p><p>  更多格式可以参考<a href="http://www.gnu.org/software/tar/manual/html_node/gzip.html" target="_blank" rel="external">这里</a>。当然，最为常用的两种格式为<code>gzip</code>跟<code>bzip2</code>，用法示例如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar czvf tmp.tgz tmp/</div><div class="line">tar cjvf tmp.bz2 tmp/</div></pre></td></tr></table></figure><p>  其中<code>v</code>参数可选，如果不需要显示压缩过程的话。需要注意的是，<code>tar</code>压缩目录的时候会保持目录的结构。</p></li><li><p>解压文件</p><p>  对应于不同的压缩格式，解压参数稍微不一样，对于<code>gzip</code>跟<code>bzip2</code>分别示例如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar xzvf tmp.tgz</div><div class="line">tar xjvf tmp.tgz</div></pre></td></tr></table></figure><p>  与压缩不同，<code>c</code>换成<code>x</code>表示解压，其它参数含义与压缩一样。默认情况下，解压的文件会放在当前目录，如果需要解压到某个目录下，则可以用<code>-C</code>参数：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar xzvf -C /tmp/ tmp.tgz</div><div class="line">tar xjvf -C /tmp/ tmp.tgz</div></pre></td></tr></table></figure></li><li><p>列出压缩包里面的文件</p><p>  有时候我们需要先看看压缩包里面有哪些文件，但又并不想解压文件，可以采用<code>-t</code>参数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># tar czf tmp.tgz tmp/</div><div class="line"># tar tvf tmp.tgz</div><div class="line">drwxr-xr-x root/root         0 2017-11-17 02:46 tmp/</div><div class="line">-rw-r--r-- root/root         0 2017-11-16 00:17 tmp/Test1</div><div class="line">-rw-r--r-- root/root       102 2017-11-17 00:30 tmp/test.log</div><div class="line">-rw-r--r-- root/root        34 2017-11-17 02:46 tmp/test2</div></pre></td></tr></table></figure><p>  其中，<code>tvf</code>会列出压缩包中的文件，不论采用何种压缩格式，甚至是没有被压缩的TAR文件。</p></li><li><p>从压缩包中提取特定的文件</p><p>  在列出压缩包里面的内容后，如果只想提取里面的某些文件，可以这么做：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># tar xzvf tmp.tgz tmp/test.log tmp/test2</div><div class="line">tmp/test.log</div><div class="line">tmp/test2</div></pre></td></tr></table></figure><p>  其中，根据不同的压缩格式请替换成不同的参数。请务必注意，指定的文件必须是完整的路径，而不能只是文件名。</p><p>  另外，如果想提取一组匹配某种条件的文件，可以使用<code>--wildcards</code>参数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># tar xzvf tmp.tgz --wildcards &quot;*.log&quot;</div><div class="line">tmp/test.log</div></pre></td></tr></table></figure></li></ul><h1 id="split命令"><a href="#split命令" class="headerlink" title="split命令"></a>split命令</h1><p><code>split</code>命令用来将一个文件分成多个文件，比如将一个特别大的文件分成平均大小为40M的多个文件等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># split -b 40M go1.6.linux-amd64.tar.gz go1.6.linux-amd64.tar.gz.part</div><div class="line"># ll go1.6.linux-amd64.tar.gz.part*</div><div class="line">-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partaa</div><div class="line">-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partab</div><div class="line">-rw-r--r--. 1 root root   913400 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partac</div></pre></td></tr></table></figure><p>其中，<code>go1.6.linux-amd64.tar.gz</code>是要被拆分的文件，<code>go1.6.linux-amd64.tar.gz.part</code>是拆分后文件的前缀，可以看到文件被拆分为三部分了。</p><p><code>split</code>非常常见的用法是来将某个被压缩的文件拆分成小的部分，正如上例所示。那么，如何将拆分的文件重新合并呢？我们可以用<code>cat</code>将它们合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat go1.6.linux-amd64.tar.gz.part* &gt; go1.6.linux-amd64.tar.gz</div></pre></td></tr></table></figure><h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><p>过滤数据来说，用的最多的估计就是<code>grep</code>命令了，<code>grep</code>命令可以从文件或者管道中搜索数据并打印出来，当然，其也可以直接在目录中搜索所有的文件，并把其中符合条件的行打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat test.log | grep hello</div><div class="line">hello</div><div class="line"># grep hello test.log</div><div class="line">hello</div><div class="line"># grep hello . -r</div><div class="line">./test.log:hello</div></pre></td></tr></table></figure><p>上面就是三种方式搜索包括<code>hello</code>关键字的行。</p><p><code>grep</code>是Linux中使用最为频繁的命令之一，其本身也有非常强大的功能，这一节咱们将详细讲述其比较常见的用法。</p><h2 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h2><p>查看<code>grep</code>的帮助可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep --help</div><div class="line">Usage: grep [OPTION]... PATTERN [FILE]...</div></pre></td></tr></table></figure><p>其中<code>OPTION</code>指的是命令参数，<code>PATTERN</code>指的是匹配的字符串，比如关键字搜索。<code>FILE</code>指的是文件，当然，没有文件的时候也可以通过管道接收数据并搜索过滤。<code>grep</code>提供了非常多的命令参数用来控制查找的方式跟效果，下面列举其常用的一些参数：</p><p>|——+————————————————————————————————————|<br>| 参数 | 说明                                                                                                       |<br>|——+————————————————————————————————————|<br>| -i   | 默认情况下，<code>grep</code>命令的搜索是大小写敏感的，如果需要忽略大小写可以用这个参数                               |<br>| -v   | 该参数表示不包含的意思                                                                                     |<br>| -A2  | 其中<code>A</code>是<code>after</code>的意思，表示同时显示搜索出来行后面两行。有时候我们需要知道匹配行后面是什么，可以用这个参数 |<br>| -B2  | 与<code>A</code>相反，其是<code>before</code>的意思，表示同时显示匹配行前两行                                                    |<br>| -C2  | 有时候我们想既显示前面两行也显示后面两行，这时候就用这个参数                                               |<br>| -r   | 搜索目录的时候需要带上这个参数                                                                             |<br>| -n   | 有些时候，我们需要知道匹配到的行是第几行，可以加上这个参数把行号打印出来                                   |<br>|——+————————————————————————————————————|</p><p>对于<code>PATTERN</code>，<code>grep</code>命令也支持不同的用法：</p><ul><li>关键字匹配</li></ul><p>这个是最常用的基本用法，匹配是否包括该关键字的行。</p><ul><li>正则匹配</li></ul><p>除了基本的关键字匹配，<code>grep</code>还支持极为强大的正则表达式的匹配。我们将在下一小节专门讲述正则表达式匹配。</p><ul><li>或匹配</li></ul><p>有时候我们需要匹配某个PATTERN1或者PATTERN2的行，这时候可以这么写<code>PATTERN</code>：<code>PATTERN1\|PATTERN2</code>。通过<code>\|</code>将多个<code>PATTERN</code>连在一起表示或的意思，只要匹配其中任一个的行都会被打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># grep &apos;12306\|test&apos; . -r</div><div class="line">./test2:http://abcdefg.test.com</div><div class="line">./test2:12306.com</div></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><code>grep</code>命令支持非常强大的正则匹配，支持三种不同的正则表达式：</p><ul><li><a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions" target="_blank" rel="external">ERE</a>(POSIX-Extended Regular Expressions)</li><li><a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions" target="_blank" rel="external">BRE</a>(POSIX_Basic_Regular_Expressions)</li><li><a href="https://perldoc.perl.org/perlre.html" target="_blank" rel="external">Perl Regular expression</a></li></ul><p>当然，比较常用的是<code>ERE</code>正则表达式了。在<code>grep</code>命令中，采用<code>-E</code>参数即可以使用该表达式，正则表达式非常灵活，用法非常多，这里列举几个示例：</p><ul><li><p>匹配以关键字开头的行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -E "^keyword" . -r</div></pre></td></tr></table></figure></li><li><p>匹配以关键字结尾的行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -E "keyword$" . -r</div></pre></td></tr></table></figure></li><li><p>匹配包含如<code>2017/10/11</code>日期的行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -E "[0-9]&#123;4&#125;/[0-9]&#123;2&#125;/[0-9]&#123;2&#125;" . -r</div></pre></td></tr></table></figure><p>  注意的是，对于数字的表示，其不支持如<code>\d</code>这样的表达方式，而需要<code>[0-9]</code>这样表达。</p></li></ul><p>当然，如果需要熟练掌握<code>grep</code>的正则表达式匹配，你必须对正则表达式非常熟悉，这个就不在本篇的范畴了。</p><h1 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h1><p>要说Linux中最为强大的基本命令有哪些，那<code>awk</code>无疑会榜上有名，其强大的流式处理能力，很多人甚至写书来专门讲这个命令。这里咱们暂时介绍基本的功能，以后有机会将专门开辟一文来展开。</p><p>一个常见的用法就是把文件中的某几列打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out</div><div class="line"># cat test.log | awk &apos;&#123;print $1, $2, $3&#125;&apos;</div><div class="line">Nov 17 00:27:20</div></pre></td></tr></table></figure><p>如上例，空格将一行分成了不同的列，咱们希望只把时间显示出来，而时间包括了第1，2，3列，因此，通过<code>awk &#39;{print $1, $2, $3}&#39;</code>就实现了此功能，其中<code>$1</code>就是引用第一列。</p><h1 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h1><p>有时候，一行内的数据并不是通过空格分隔开的，而是通过其它分隔符，那如何显示想要的列呢？通过<code>cut</code>命令，咱们同样可以轻松实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># head -n 5 /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</div><div class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div><div class="line"># head -n 5 /etc/passwd | cut -d: -f1</div><div class="line">root</div><div class="line">bin</div><div class="line">daemon</div><div class="line">adm</div><div class="line">lp</div></pre></td></tr></table></figure><p><code>/etc/passwd</code>中的每一行基本上都是通过<code>:</code>进行分隔，其中第一列表示用户名，如果咱们只想把用户名输出的话，可以通过<code>cut -d: -f1</code>来实现，其中<code>-d:</code>表示以<code>:</code>号为分隔符，<code>-f1</code>表示显示第一列。可见，对于<code>cut</code>命令来说，咱们可以指定分隔符，那么前面通过<code>awk</code>实现的例子也可以通过<code>cut</code>来做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out</div><div class="line"># cat test.log | cut -d&quot; &quot; -f1-3</div><div class="line">Nov 17 00:27:20</div></pre></td></tr></table></figure><p>其中<code>-d&quot; &quot;</code>表示以空格为分隔符（注意，这里的空格必须以引号括起来，不然会被shell展开去除多余空格），<code>-f1-3</code>表示输出第1到3列，这里简用了<code>-</code>来表示范围，当然也可以写成<code>-f1,2,3</code>了。</p><p>此外，<code>cut</code>命令还可以指定输出哪些位的字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out</div><div class="line"># cat test.log | cut -c1-16</div><div class="line">Nov 17 00:27:20</div></pre></td></tr></table></figure><p>其中，<code>-c1-16</code>表示输出第1到16个字符，当然，你同样可以以<code>,</code>来分别列举要输出哪几个。</p><h1 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h1><p><code>tr</code>其实是<code>translate</code>的缩写，这个命令用来将某些字符翻译成另外的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># tr --help</div><div class="line">Usage: tr [OPTION]... SET1 [SET2]</div></pre></td></tr></table></figure><p>这个命令就是把字符集<code>SET1</code>中的字符对应的转成字符集<code>SET2</code>中的字符。如将小写转成大写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out</div><div class="line"># cat test.log | tr a-z A-Z</div><div class="line">NOV 17 00:27:20 TRAFFIC-BASE1 NAMED[1212]: MANAGED-KEYS-ZONE: UNABLE TO FETCH DNSKEY SET .: TIMED OUT</div></pre></td></tr></table></figure><p>这里用<code>-</code>来方便的表示一定范围的字符集，当然，你完全可以一个个列出来你要的字符集。通常情况下，<code>SET1</code>跟<code>SET2</code>的长度保持一致，因为这个转换实际上是一对一的转换，当然，<code>SET2</code>的长度是可以大于<code>SET1</code>的，多余的字符不会被使用。但是，当<code>SET2</code>长度小于<code>SET1</code>时，<code>tr</code>命令会将<code>SET2</code>中最后一个字符填充不足的位数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo &apos;abcdefg&apos; | tr ab wyz</div><div class="line">wycdefg</div><div class="line"># echo &apos;abcdefg&apos; | tr abcdefg wyz</div><div class="line">wyzzzzz</div></pre></td></tr></table></figure><p>对于<code>tr</code>还有一个常见的用途，就是用来去除字符串中的换行符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># head -n 5 /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</div><div class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div><div class="line"># head -n 5 /etc/passwd | tr &apos;\n&apos; &apos; &apos;</div><div class="line">root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div></pre></td></tr></table></figure><p>其中，<code>\n</code>表示换行符，示例中将换行符全部换成了空格。</p><p>最后，<code>tr</code>还有一个常见的用法，可以加上<code>-d</code>参数来删除字符集中的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo abcdeWXYZ | tr -d a-z</div><div class="line">WXYZ</div></pre></td></tr></table></figure><p>示例中删除了所有小写字母。</p><h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><p>流式处理中，<code>sed</code>也是一个极为常用的命令，它可以用来替换字串，比之前的<code>tr</code>那是要强大无数倍了。</p><p>查看<code>sed</code>的帮助：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># sed --help</div><div class="line">Usage: sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</div></pre></td></tr></table></figure><p>它既可以直接在文件中替换字符串，也可以加收管道的数据。如基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo abcdefgabcd | sed &apos;s/abc/ABC/&apos;</div><div class="line">ABCdefgabcd</div></pre></td></tr></table></figure><p>其中<code>&#39;s/abc/ABC/&#39;</code>指定了替换的规则，默认情况下只替换一次，如果需要全部替换，则需要在规则后面加入<code>g</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo abcdefgabcd | sed &apos;s/abc/ABC/g&apos;</div><div class="line">ABCdefgABCd</div></pre></td></tr></table></figure><p>规则中默认使用了<code>/</code>为分隔。当然，你也可以使用其他分隔符，这在要替换的字串中带有<code>/</code>的时候特别有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo &quot;http://abc.test.com&quot; | sed &apos;s/http:\/\//https:\/\//&apos;</div><div class="line">https://abc.test.com</div><div class="line"># echo &quot;http://abc.test.com&quot; | sed &apos;s|http://|https://|&apos;</div><div class="line">https://abc.test.com</div></pre></td></tr></table></figure><p>如果不指定新的分隔符<code>|</code>，那么就得使用转义符<code>\</code>将<code>//</code>进行转义了，这样可读性就差了很多，采用<code>|</code>就自然多了。<code>sed</code>支持的分隔符还包括了<code>:</code>，<code>_</code>。</p><p>此外，<code>sed</code>不仅可以用来替换字串，还可以用来删除匹配的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat test2</div><div class="line">http://abcdefg.test.com</div><div class="line">12306.com</div><div class="line"># cat test2 | sed &apos;/12306/d&apos;</div><div class="line">http://abcdefg.test.com</div></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul><li><p>后向引用（Back Referencing）</p><p>  <code>sed</code>规则匹配到的字符串还可以在规则定义中被引用，如下例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo &quot;hello world&quot; | sed &apos;s/hello/&amp;&amp;/&apos;</div><div class="line">hellohello world</div></pre></td></tr></table></figure><p>  其中，<code>&amp;</code>可以用来引用被匹配到的字串，在本例中，匹配到的字串是<code>hello</code>，这样通过<code>&amp;</code>就可以引用被匹配到的字串了。此外，我们还可以通过<code>()</code>来指定匹配的字串，并用<code>\1</code>（数字表示第一个<code>()</code>）来引用（实际上是正则表达式中的Grouping）：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo Sunday | sed &apos;s/\(Sun\)/\1ny/&apos;</div><div class="line">Sunnyday</div><div class="line"># echo Sunday | sed &apos;s/\(Sun\)/\1ny \1/&apos;</div><div class="line">Sunny Sunday</div></pre></td></tr></table></figure></li><li><p>正则匹配</p><p>  由上述可以看出，<code>sed</code>的规则使用了正则表达式规则，但是其书写跟一般的正则书写不一样，你必须将有关的字符转义，否则<code>sed</code>仍然会将其当做普通字符进行匹配：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo &quot;this is aaaa cat&quot; | sed &apos;s/a&#123;4&#125;/a/&apos;</div><div class="line">this is aaaa cat</div><div class="line"># echo &quot;this is aaaa cat&quot; | sed &apos;s/a\&#123;4\&#125;/a/&apos;</div><div class="line">this is a cat</div></pre></td></tr></table></figure><p>  可以看出，在没有转义<code>{</code>及<code>}</code>之前，<code>sed</code>并没有匹配到目标字串<code>aaaa</code>，而将其转义之后，则以正则表达式<code>a{4}</code>匹配到了<code>aaaa</code>并进行了替换。</p></li><li><p>递归替换</p><p>  有时候我们需要在项目目录下替换某个字串，比如把手误写错的<code>#include&lt;stdllib.h&gt;</code>全部替换成<code>#include&lt;stdlib.h&gt;</code>，希望被替换的文件包括<code>*.cpp</code>，<code>*.h</code>的文件。其中的一种做法如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ head -n 1 test.cpp</div><div class="line">#include &lt;stdllib.h&gt;</div><div class="line">$ sed -i &apos;s/#include &lt;stdllib.h&gt;/#include &lt;stdlib.h&gt;/&apos; `find . -name &quot;*.cpp&quot; -o -name &quot;*.h&quot;`</div><div class="line">$ head -n 1 test.cpp</div><div class="line">#include &lt;stdlib.h&gt;</div></pre></td></tr></table></figure><p>  这里用到了shell嵌入的用法（可以参看<a href="https://keysaim.github.io/2017/10/10/linux-study-shell-basic/#shell嵌入与shell选项" target="_blank" rel="external">这一篇博文</a>)，通过<code>find</code>命令找出所有的源文件，然后用<code>sed -i</code>进行替换，其中<code>-i</code>表示从文件里面替换。这一用法会将<code>find</code>找到的所有文件作为参数都追加到<code>sed</code>命令后，在项目非常大的情况下可能会导致命令执行失败（因为数量庞大的文件导致追加的参数太大了），通常我们推荐采用<code>find</code>的这种用法：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">"*.cpp"</span> -o -name <span class="string">"*.h"</span> -<span class="built_in">exec</span> sed -i <span class="string">'s/#include &lt;stdllib.h&gt;/#include &lt;stdlib.h&gt;/'</span> &#123;&#125; \;</div></pre></td></tr></table></figure><p>  具体可以参照本文中关于<code>find</code>命令的介绍。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cat命令&quot;&gt;&lt;a href=&quot;#cat命令&quot; class=&quot;headerlink&quot; title=&quot;cat命令&quot;&gt;&lt;/a&gt;cat命令&lt;/h1&gt;&lt;p&gt;很多时候我们通过&lt;code&gt;cat&lt;/code&gt;命令来查看文件内容，它会将文件的所有内容显示出来。当然，&lt;code&gt;cat&lt;/code&gt;也可以通过管道接收数据，它主要完成的是将从管道接收的输入导到输出。&lt;/p&gt;
&lt;h1 id=&quot;more跟less命令&quot;&gt;&lt;a href=&quot;#more跟less命令&quot; class=&quot;headerlink&quot; title=&quot;more跟less命令&quot;&gt;&lt;/a&gt;more跟less命令&lt;/h1&gt;&lt;p&gt;有时候用&lt;code&gt;cat&lt;/code&gt;命令来显示一个较大的文件并不方便，整个文件内容一次性显示出来简直就是刷屏了。如果需要一页页的显示内容，可以使用&lt;code&gt;more&lt;/code&gt;或者&lt;code&gt;less&lt;/code&gt;命令，这两个命令会以分页的形式显示文件内容，至于使用哪个命令完全看个人习惯了。此外，这两个命令不仅可以分页显示，而且在分页模式下，你可以用快捷键方便的浏览及搜索：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 按`d`下翻页
* 按空格下翻页
* 按回车下移一行
* 按`/`进入搜索模式，输入要搜索的关键字，按回车搜索。
* 按`n`搜索下一个
* 按`q`退出查看
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="study" scheme="http://github.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习（四）IO重定向与管道</title>
    <link href="http://github.com/2018/04/14/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89IO%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://github.com/2018/04/14/Linux学习（四）IO重定向与管道/</id>
    <published>2018-04-14T15:06:32.000Z</published>
    <updated>2018-04-14T15:07:22.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO重定向-IO-redirection"><a href="#IO重定向-IO-redirection" class="headerlink" title="IO重定向(IO redirection)"></a>IO重定向(IO redirection)</h1><p>Linux的有一个强大之处就是可以通过管道(Pipe)跟IO重定向将一系列命令的输出跟输入连接起来。IO重定向是Linux中非常重要的概念，是理解Linux命令，脚本以及Linux IO的基础。</p><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>对于<code>shell</code>来说，有三个基础的流，标准输入流(stdin或者stream 0)，标准输出流(stdout或者stream 1)，标准错误流(stderr或者stream2)。</p><p><img src="/img/blog-linux-shell-stdinout.png" alt="标准输入输出"></p><p>举个例子，当我们用键盘在<code>shell</code>中执行命令的时候，可以如下图：</p><p><img src="/img/blog-linux-shell-keyboard-stdinout.png" alt="键盘输入输出"></p><p>通常，stdout跟stderr都输出到了屏幕上，但对于Linux来说，其实是两种不同的输出。<br><a id="more"></a></p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>可以用<code>&gt;</code>大于号将stdout重定向到另一个IO，比如文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># echo &quot;hello&quot; &gt; test.log</div><div class="line"># cat test.log</div><div class="line">hello</div></pre></td></tr></table></figure><p>上面的命令将stdout重定向到文件<code>test.log</code>中，此时，如果该文件不存在则创建新文件，如果存在则覆盖已有文件。事实上，<code>&gt;</code>重定向是<code>1&gt;</code>的简写，<code>1&gt;</code>可以更清楚的看到实际上是把stdout(stream 1)重定向。</p><p>必须注意的是，默认情况下，该重定向会覆盖已有文件，这个在有时候可能不经意间丢失重要数据。<code>shell</code>提供了选项使得我们可以禁止这种覆盖，<code>set -o noclobber</code>可以打开该选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">hello</div><div class="line"># set -o noclobber</div><div class="line"># echo &quot;world&quot; &gt; test.log</div><div class="line">-bash: test.log: cannot overwrite existing file</div></pre></td></tr></table></figure><p>此外，在打开该选项之后，其实还是可以强制执行覆盖，可以采用<code>&gt;|</code>来强制重定向到已存在的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># echo &quot;world&quot; &gt; test.log</div><div class="line">-bash: test.log: cannot overwrite existing file</div><div class="line"># echo &quot;world&quot; &gt;| test.log</div><div class="line"># cat test.log</div><div class="line">world</div></pre></td></tr></table></figure><h2 id="追加输出"><a href="#追加输出" class="headerlink" title="追加输出"></a>追加输出</h2><p>可以采用<code>&gt;&gt;</code>将输出重定向到文件并追加在文件结尾，这样就可以避免覆盖文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">world</div><div class="line"># echo hello &gt;&gt; test.log</div><div class="line"># cat test.log</div><div class="line">world</div><div class="line">hello</div></pre></td></tr></table></figure><h2 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h2><p>如<code>1&gt;</code>一样，我们可以通过<code>2&gt;</code>将stderr重定向到文件，具体行为跟stdout类似。</p><h2 id="同时重定向stdout跟stderr"><a href="#同时重定向stdout跟stderr" class="headerlink" title="同时重定向stdout跟stderr"></a>同时重定向stdout跟stderr</h2><p>我们可以在同一行命令中同时将stdout跟stderr重定向，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ls test* tttt*</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">test.log  test2</div><div class="line"># ls test* tttt* &gt; stdout.log 2&gt; stderr.log</div><div class="line"># cat stdout.log</div><div class="line">test.log</div><div class="line">test2</div><div class="line"># cat stderr.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div></pre></td></tr></table></figure><p>可以看出，stdout跟stderr被分别重定向到<code>stdout.log</code>跟<code>stderr.log</code>文件中了。</p><p>此外，还有一个常见的用法是将stderr重定向到stdout，这样就可以将所有输出都定向在一起了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ls test* tttt* &gt; stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line"># cat stdout.log</div><div class="line">test.log</div><div class="line">test2</div><div class="line"># ls test* tttt* &gt; stdout.log 2&gt;&amp;1</div><div class="line"># cat stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">test.log</div><div class="line">test2</div></pre></td></tr></table></figure><p>可见，通过<code>2&gt;&amp;1</code>将stderr重定向给stdout，而stdout又重定向给文件<code>stdout.log</code>，这样所有的输出都重定向到文件<code>stdout.log</code>中了。另外，还可以通过<code>&amp;&gt;</code>直接将stderr跟stdout合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ls -l test* tttt* &amp;&gt; stdout.log</div><div class="line"># cat stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div><div class="line">-rw-r--r--. 1 root root  0 Nov 16 00:17 test2</div></pre></td></tr></table></figure><h2 id="重定向顺序"><a href="#重定向顺序" class="headerlink" title="重定向顺序"></a>重定向顺序</h2><p>将stderr重定向给stdout的时候，请务必注意其顺序，如上面的重定向如果写成这样，结果就完全不同了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ls test* tttt* 2&gt;&amp;1 &gt; stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line"># cat stdout.log</div><div class="line">test.log</div><div class="line">test2</div></pre></td></tr></table></figure><p>可以看出，stderr其实并没有被重定向到文件<code>stdout.log</code>中，可见顺序是非常重要的。那么，如果理解这种不同呢？咱们可以这么样来理解：</p><ul><li>将<code>&gt;</code>看作是<code>shell</code>中的赋值操作<code>=</code></li><li>将stdout跟stderr看作是变量，但对其引用采用<code>&amp;</code>，这样<code>&amp;1</code>表示对stdout变量的引用</li><li>假定stdout跟stderr变量的初始值是屏幕，将屏幕记为<code>/dev/tty</code></li><li><code>shell</code>从左到有扫描解释命令，并对stdout跟stderr分别赋值</li><li>查看stdout跟stderr的最终值即可知道分别被重定向到哪里了</li></ul><p>还是以上面的例子来解释，<code>ls test* tttt* 2&gt;&amp;1 &gt; stdout.log</code></p><ul><li>命令开始前，stdout=/dev/tty, stderr=/dev/tty</li><li><code>shell</code>从左到右扫描并重新赋值，首先<code>2&gt;&amp;1</code>就相当于<code>stderr=$stdin</code>，此时<code>stderr</code>的值其实还是<code>/dev/tty</code></li><li><code>&gt; stdout.log</code>就相当于<code>stdout=stdout.log</code>，此时stdout值为<code>stdout.log</code></li><li>最后，stdout值为<code>stdout.log</code>，而stderr值仍然为<code>/dev/tty</code>，所以只有stdout输出到文件<code>stdout.log</code>中了</li></ul><p>基于这个原则，在讲述完管道之后咱们将展示如何把stdout跟stderr交换一下。</p><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><ul><li><code>&lt;</code>符号</li></ul><p>既然输出有重定向，那么输入是否也可以呢？答案是肯定的，可以采用<code>&lt;</code>将输入重定向，<code>&lt;</code>其实是<code>0&lt;</code>的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># cat stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div><div class="line">-rw-r--r--. 1 root root  0 Nov 16 00:17 test2</div><div class="line"># cat &lt;stdout.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div><div class="line">-rw-r--r--. 1 root root  0 Nov 16 00:17 test2</div></pre></td></tr></table></figure><ul><li><code>&lt;&lt;</code>符号</li></ul><p>此外，还可以<code>&lt;&lt;EOF</code>通过手动输入直到输入<code>EOF</code>（或者Ctrl-D）。</p><ul><li><code>&lt;&lt;&lt;</code>符号</li></ul><p>该符号可以直接将一个字符串重定向给输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># base64 &lt;&lt;&lt; hello</div><div class="line">aGVsbG8K</div></pre></td></tr></table></figure><p><code>base64</code>命令参数只接受文件，通过这种方式就可以把字符串直接传给它。</p><h2 id="输入输出同时重定向"><a href="#输入输出同时重定向" class="headerlink" title="输入输出同时重定向"></a>输入输出同时重定向</h2><p><code>shell</code>是可以支持同时重定向输入跟输出的，以下方式都会被准确解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat &lt;test.log &gt; stdout.log 2&gt; stderr.log</div><div class="line"># &lt;test.log &gt; stdout.log 2&gt; stderr.log cat</div></pre></td></tr></table></figure><h2 id="快速清除文件内容"><a href="#快速清除文件内容" class="headerlink" title="快速清除文件内容"></a>快速清除文件内容</h2><p>可以通过重定向快速的清空文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat test.log</div><div class="line">hello world</div><div class="line"># &gt; test.log</div><div class="line"># cat test.log</div><div class="line">#</div></pre></td></tr></table></figure><p>可见，咱们并不需要写<code>echo &quot;&quot; &gt; test.log</code>这样的命令来清空一个文件。当<code>noclobber</code>选项被打开时，可以通过<code>&gt;|</code>来强制清空。</p><h1 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h1><p>在Linux中，我们可以使用管道(Pipe)将前一个命令的stdout作为输入给后面一个命令，管道由<code>|</code>表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ls test* tttt*</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">test.log  test2</div><div class="line"># ls -l test* tttt* | grep log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div></pre></td></tr></table></figure><p>请务必注意的是，管道只会将stdout传递给下一个命令，stderr并不会传递，为了证明这一点，咱们将后一个命令的stderr重定向到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ls -l test* tttt* | grep log 2&gt; stderr.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div><div class="line"># cat stderr.log</div><div class="line">#</div></pre></td></tr></table></figure><p>这时可以看出，第二个命令的stderr为空，而第一个命令的stderr仍输出到屏幕了。当然，咱们也可以将第一个命令的stderr重定向到stdout上，这样<code>grep</code>命令也可以收到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ls -l test* tttt* 2&gt;&amp;1 | grep &quot;No &quot;</div><div class="line">ls: cannot access tttt*: No such file or directory</div></pre></td></tr></table></figure><p>再回到上一节的问题，咱们如何将stdout跟stderr互相交换一下呢？可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ls -l test* tttt* 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 | grep &quot;No &quot; 2&gt; stderr.log</div><div class="line">ls: cannot access tttt*: No such file or directory</div><div class="line">-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log</div><div class="line">-rw-r--r--. 1 root root  0 Nov 16 00:17 test2</div><div class="line"># cat stderr.log</div><div class="line">#</div></pre></td></tr></table></figure><p>如果你的Linux发行版本对grep输出的颜色设置正确，会发现只有第一行是grep出来的，由此可见<code>3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code>居然将stdout跟stderr互换了一下，至于怎么解释，可以参照前面的赋值方式自行拆解一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO重定向-IO-redirection&quot;&gt;&lt;a href=&quot;#IO重定向-IO-redirection&quot; class=&quot;headerlink&quot; title=&quot;IO重定向(IO redirection)&quot;&gt;&lt;/a&gt;IO重定向(IO redirection)&lt;/h1&gt;&lt;p&gt;Linux的有一个强大之处就是可以通过管道(Pipe)跟IO重定向将一系列命令的输出跟输入连接起来。IO重定向是Linux中非常重要的概念，是理解Linux命令，脚本以及Linux IO的基础。&lt;/p&gt;
&lt;h2 id=&quot;标准输入输出&quot;&gt;&lt;a href=&quot;#标准输入输出&quot; class=&quot;headerlink&quot; title=&quot;标准输入输出&quot;&gt;&lt;/a&gt;标准输入输出&lt;/h2&gt;&lt;p&gt;对于&lt;code&gt;shell&lt;/code&gt;来说，有三个基础的流，标准输入流(stdin或者stream 0)，标准输出流(stdout或者stream 1)，标准错误流(stderr或者stream2)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/blog-linux-shell-stdinout.png&quot; alt=&quot;标准输入输出&quot;&gt;&lt;/p&gt;
&lt;p&gt;举个例子，当我们用键盘在&lt;code&gt;shell&lt;/code&gt;中执行命令的时候，可以如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/blog-linux-shell-keyboard-stdinout.png&quot; alt=&quot;键盘输入输出&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常，stdout跟stderr都输出到了屏幕上，但对于Linux来说，其实是两种不同的输出。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="study" scheme="http://github.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习（三）shell基础</title>
    <link href="http://github.com/2018/04/14/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89shell%E5%9F%BA%E7%A1%80/"/>
    <id>http://github.com/2018/04/14/Linux学习（三）shell基础/</id>
    <published>2018-04-14T15:03:35.000Z</published>
    <updated>2018-04-14T15:05:08.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先，咱们来了解一下，什么是<code>Shell</code>。操作系统内核给我们提供了各种接口，同时也提供了各种用户层的库，理论上我们基于这些可以编写程序实现各种我们想要的功能，不过问题是，咱们不可能做什么事情都要重新编写程序，这样使用起来也太困难了。因此，操作系统（包括Linux）通常都会引入一个<code>Shell</code>这样的特殊程序，这个程序会接受输入的命令然后执行，并可能将执行结果呈现出来。总结来说，<code>Shell</code>是一个从输入设备或者文件读取命令，并且解释、执行的用户态程序。</p><p>在Linux系统中，通常使用的<code>Shell</code>程序包括有：</p><ul><li>Sh (Bourne Shell)</li><li>Bash (Bourne Again Shell)</li><li>Csh (C Shell)</li><li>Ksh (Korn Shell)<a id="more"></a>一般来说，<code>Bash</code>应该是使用最多的<code>Shell</code>程序了，本文也主要基于<code>Bash</code>来展开。</li></ul><h1 id="Shell展开（Shell-Expansion）"><a href="#Shell展开（Shell-Expansion）" class="headerlink" title="Shell展开（Shell Expansion）"></a>Shell展开（Shell Expansion）</h1><p><code>Shell</code>程序是一个命令解释器，因此在终端输入命令之后，<code>Shell</code>将扫描命令并做适当的修改，这个过程称为Shell展开。Shell展开是Shell解释执行之前极为重要的一步，了解它将有利于你对Shell命令或者脚本的理解，本章节将逐步带大家来了解这个过程。</p><h2 id="命令参数解析"><a href="#命令参数解析" class="headerlink" title="命令参数解析"></a>命令参数解析</h2><p>这里的空格包括了制表符（Tab）。当Shell程序扫描输入的命令时，会以<em>连续</em>的空格为界，将命令切分成一组参数，因此你输入多个空格为界跟输入一个空格的效果是一样的。通常来讲，第一个参数就是要执行的命令，而后面的参数则是改命令的参数。一下几个命令其实是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># echo Hello World</div><div class="line">Hello World</div><div class="line"># echo   Hello World</div><div class="line">Hello World</div><div class="line">#    echo Hello World</div><div class="line">Hello World</div></pre></td></tr></table></figure><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>当然，有时候你需要在一个参数中包括空格，这样的话你就需要将这个参数以引号引起来，引号包括了单引号<code>&#39;</code>跟双引号<code>&quot;</code>，两者都可以。<code>shell</code>会将引号中的字符串视为一个参数，不论里面有没有空格。当然，特别指出的是，不要用反引号<code>` </code>，反引号将在后面详细讲述。</p><p>如命令<code>echo &#39;Hello World!&#39;</code>在<code>shell</code>解析之后会有两个参数，分别为<code>echo</code>跟<code>Hello World!</code>。而如果不用引号<code>echo Hello World!</code>，则将解析为三个参数。</p><blockquote><p>特别提一下，对于<code>echo</code>命令，如果需要输出需要转义的字符，如回车等，则需要执行<code>echo -e &quot;Hello World!\n&quot;</code>，如果不加<code>-e</code>，则<code>\n</code>会被直接显示出来。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;    # echo &quot;hello\n&quot;</div><div class="line">&gt;    hello\n</div><div class="line">&gt;    # echo -e &quot;hello\n&quot;</div><div class="line">&gt;    hello</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>对于<code>shell</code>来说，命令有内部命令（Builtin Commands）跟外部命令（External Commands）之分，所谓内部命令指的是包含在<code>shell</code>解析器中的命令。内部命令一般有<a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands" target="_blank" rel="external">4种类型</a>：</p><ul><li><p><code>sh</code>内部命令</p><p>  这些内部命令来源于<code>Bourne Shell</code>，通常包括了以下命令：<br>  <code>: . break cd continue eval exec exit export getopts hash pwd readonly return shift test/[ times trap umask unset</code>。</p></li><li><p><code>bash</code>内部命令</p><p>  这些内部命令来源于<code>Bourne Again Shell</code>，通常包括了以下命令：<br>  <code>alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias</code>。</p></li><li><p>修改<code>shell</code>行为的内部命令</p><p>  这些内部命令用来修改<code>shell</code>的默认行为。包括了<code>set shopt</code>命令。</p></li><li><p>特殊内部命令</p><p>  由于历史原因，POSIX标准将一些内部命令划分为特殊内部命令，特殊的之处在于这些命令的查找时间以及命令运行后的状态等方面，只有当Bash以<a href="http://www.gnu.org/software/bash/manual/bashref.html#Bash-POSIX-Mode" target="_blank" rel="external">POSIX模式</a>运行时，这些命令才是特殊命令，否则它们跟其它内部命令没啥区别。特殊内部命令包括了<code>break : . continue eval exec exit export readonly return set shift trap unset</code>。</p></li></ul><p><strong>内部命令可能会被提前至于内存中，因此运行起来会比外部命令要快。</strong>对于外部命令，可以认为除了内部命令之后就可以认为是外部命令了，通常来讲，<code>/bin</code>跟<code>/sbin</code>下的都是外部命令，当然，应用有关的通常也是外部命令。</p><p>我们可以通过<code>type</code>命令来查看一个命令是否是内部命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># type cd</div><div class="line">cd is a shell builtin</div><div class="line"># type awk</div><div class="line">awk is /usr/bin/awk</div></pre></td></tr></table></figure><p>另外，对于很多内部命令，它们可能对应的会有外部命令版本，可以通过<code>type</code>命令来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># type -a echo</div><div class="line">echo is a shell builtin</div><div class="line">echo is /usr/bin/echo</div><div class="line"># type -a cd</div><div class="line">cd is a shell builtin</div><div class="line">cd is /usr/bin/cd</div></pre></td></tr></table></figure><p>反过来，我们一般可以通过命令<code>which</code>来查询一个命令是否是外部命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># which awk</div><div class="line">/usr/bin/awk</div><div class="line"># which .</div><div class="line">/usr/bin/which: no . in (/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</div></pre></td></tr></table></figure><p>总结一下，通过<code>which</code>查询出来的是其外部命令版本，通过<code>type</code>默认查询出来的是内部命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># which echo</div><div class="line">/usr/bin/echo</div><div class="line"># type echo</div><div class="line">echo is a shell builtin</div></pre></td></tr></table></figure><p>对于内部命令的详细说明，可以查看<a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands" target="_blank" rel="external">GNU的文档</a>。</p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>可以用<code>alias</code>命令给一个命令取一个别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># alias print=echo</div><div class="line"># print &quot;hello&quot;</div><div class="line">hello</div><div class="line"># type print</div><div class="line">print is aliased to `echo&apos;</div></pre></td></tr></table></figure><p>别名一个常用的用法是用来缩写已知的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># type ls</div><div class="line">ls is aliased to `ls --color=auto&apos;</div></pre></td></tr></table></figure><p>可见<code>ls</code>命令实际上是命令<code>ls --color=auto</code>的别名，这样就相当于改变了<code>ls</code>命令的默认行为了。在这种情况下，如果仍然想用原先的命令，可以在别名前加反斜杠<code>\</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># type ls</div><div class="line">ls is aliased to `ls --color=auto&apos;</div><div class="line"># \ls</div><div class="line">Test1  test2  test.cpp  test.log  time.log</div></pre></td></tr></table></figure><p>前面咱们通过<code>type</code>命令来查看命令的别名，实际上更加推荐采用<code>alias</code>或者<code>which</code>来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># alias ls</div><div class="line">alias ls=&apos;ls --color=auto&apos;</div><div class="line"># which ls</div><div class="line">alias ls=&apos;ls --color=auto&apos;</div><div class="line">    /usr/bin/ls</div></pre></td></tr></table></figure><p>如果要取消别名，则可以采用<code>unalias</code>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># which ls</div><div class="line">alias ls=&apos;ls --color=auto&apos;</div><div class="line">    /usr/bin/ls</div><div class="line"># unalias ls</div><div class="line"># which ls</div><div class="line">/usr/bin/ls</div></pre></td></tr></table></figure><h2 id="显示shell展开的结果"><a href="#显示shell展开的结果" class="headerlink" title="显示shell展开的结果"></a>显示shell展开的结果</h2><p>由于<code>shell</code>展开的存在，你输入的命令被展开之后可能会发生变化，如果需要知道<code>shell</code>展开之后的命令，可以使用内部命令<code>set</code>来修改<code>shell</code>的默认参数来显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># set -x</div><div class="line">++ printf &apos;\033]0;%s@%s:%s\007&apos; root traffic-base1 &apos;~&apos;</div><div class="line"># echo hello         world</div><div class="line">+ echo hello world</div><div class="line">hello world</div><div class="line">++ printf &apos;\033]0;%s@%s:%s\007&apos; root traffic-base1 &apos;~&apos;</div></pre></td></tr></table></figure><p>其中，以<code>+</code>开头的就是展开之后的命令，可见展开之后，<code>shell</code>将多余的空格去掉了。如果不要再显示了，可以输入命令<code>set +x</code>。</p><h1 id="shell控制操作符-Control-Operators）"><a href="#shell控制操作符-Control-Operators）" class="headerlink" title="shell控制操作符 (Control Operators）"></a>shell控制操作符 (Control Operators）</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="$?操作符"></a><code>$?</code>操作符</h2><p>每个命令执行完后都会有个退出码（Exit Code），其值为0时表示命令成功，否则命令失败。这个退出码可以通过<code>$?</code>来访问，执行完命令后立马访问<code>$?</code>可以获取该命令的退出码，并以此来判断命令是否成功。每个命令的执行都会产生新的退出码，所以请务必在命令执行完，立刻访问<code>$?</code>来获取退出码。</p><p>初看起来，<code>$?</code>似乎是一个<code>shell</code>变量，但实际上并非如此，因为你无法对<code>$?</code>赋值。<code>$?</code>准确来说是<code>shell</code>的一个内部参数。</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号;"></a>分号<code>;</code></h2><p><code>shell</code>命令输入时，你可以将多个命令输入在一行，只要在不同命令之间以分号<code>;</code>隔开，当然分号不能是在引号中。</p><blockquote><p>必须注意的是，如果将多个命令以<code>;</code>连接在一起，执行的结果通过<code>$?</code>查询出来将只是最后一个命令的结果</p></blockquote><h2 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp;符号"></a><code>&amp;</code>符号</h2><p>通常情况下，<code>shell</code>会在前台执行命令，并等待命令结束才返回。如果需要将命令放到后台去执行，可以使用<code>&amp;</code>符号放在命令最后面，这样的话命令会被放在后台执行，<code>shell</code>会立刻返回而不用等待命令结束。</p><blockquote><p>注意的是，即便放在后台执行，但是如果不处理好命令的输入，则命令的输出可能会继续在当前的终端输出，后面会讲述如何处理命令的输出。</p></blockquote><h2 id="amp-amp-操作符"><a href="#amp-amp-操作符" class="headerlink" title="&amp;&amp;操作符"></a><code>&amp;&amp;</code>操作符</h2><p>此操作符表示逻辑与，你可以将两个命令用此操作符连接起来，如<code>cmd1 &amp;&amp; cmd2</code>，只有当<code>cmd1</code>执行成功之后，<code>cmd2</code>才会被执行。这里的成功指的是<code>cmd1</code>的退出码是0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># hello &amp;&amp; echo world</div><div class="line">-bash: hello: command not found</div><div class="line"># echo hello &amp;&amp; echo world</div><div class="line">hello</div><div class="line">world</div></pre></td></tr></table></figure><p>当然，<code>&amp;&amp;</code>也可以将多个命令连接起来，其执行类似，只有当前面的命令成功，后面的才会执行。因此，将多个命令写在一行用<code>&amp;&amp;</code>可以实现，只不过<code>&amp;&amp;</code>必须按照逻辑与的关系执行，而<code>;</code>号的话会执行所有的命令。</p><h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="||操作符"></a><code>||</code>操作符</h2><p>很显然，与<code>&amp;&amp;</code>相对，<code>||</code>操作符表示逻辑或的关系，同样可以连接两个命令，如<code>cmd1 || cmd2</code>，只有当<code>cmd1</code>失败了，才会执行<code>cmd2</code>，这里的失败指的是<code>cmd1</code>的退出码非0。</p><h2 id="amp-amp-与-混合"><a href="#amp-amp-与-混合" class="headerlink" title="&amp;&amp;与||混合"></a><code>&amp;&amp;</code>与<code>||</code>混合</h2><p>这两个操作符是可以混合使用的，其遵循的原则保持一致，且是从左向右依次判断，结合这两种操作符，可以实现类似于<code>if then else</code>的逻辑结构。如<code>cmd1 &amp;&amp; cmd2 || cmd3</code>意思就是如果<code>cmd1</code>成功，则执行<code>cmd2</code>，否则执行<code>cmd3</code>。但务必注意的是，此处并非真正意思上的<code>if then else</code>逻辑，因为如果<code>cmd2</code>也执行失败，<code>cmd3</code>其实也会被执行。如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># echo hello &amp;&amp; echo ok || echo world</div><div class="line">hello</div><div class="line">ok</div><div class="line"># echo hello &amp;&amp; rm dfsdf || echo world</div><div class="line">hello</div><div class="line">rm: cannot remove ‘dfsdf’: No such file or directory</div><div class="line">world</div></pre></td></tr></table></figure><p><code>&amp;&amp;</code>相当于将两条命令逻辑上连成了一条命令，这样就变成了<code>cmd1-2 || cmd3</code>，其中<code>cmd1-2</code>就是<code>cmd1 &amp;&amp; cmd2</code>，因此，<code>cmd3</code>只要在<code>cmd1-2</code>失败的情况下都会被执行，而<code>cmd1-2</code>失败的情况有两种，一种是<code>cmd1</code>失败，一种是<code>cmd1</code>成功但是<code>cmd2</code>失败。同样的，<code>||</code>也会将两条命令连成一条命令，如<code>cmd1-2 || cmd3 &amp;&amp; cmd4</code>就相当于<code>cmd1-2_3 &amp;&amp; cmd4</code>，<code>cmd4</code>是否会执行，决定于<code>cmd1-2_3</code>是否失败，以具体例子说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># echo hello &amp;&amp; echo ok || echo world &amp;&amp; rm dsdfsf || echo end</div><div class="line">hello</div><div class="line">ok</div><div class="line">rm: cannot remove ‘dsdfsf’: No such file or directory</div><div class="line">end</div></pre></td></tr></table></figure><p>这行命令相当于<code>cmd1 &amp;&amp; cmd2 || cmd3 &amp;&amp; cmd4 || cmd5</code>，可以看出<code>cmd1</code>，<code>cmd2</code>，<code>cmd4</code>还是有<code>cmd5</code>被执行了，而<code>cmd3</code>没有执行。咱们来解析一下，为何是如此的执行结果。首先，<code>shell</code>从左往右扫描执行：</p><ul><li>发现<code>cmd1 &amp;&amp; cmd2</code>，由<code>&amp;&amp;</code>连成一个命令<code>cmd1-2</code>，因为两个命令都是成功的，所以都被执行了，这样可以认为<code>cmd1-2</code>成功</li><li>执行成功之后，接下来是<code>||</code>操作符，这里并不会因为前面的命令是成功的，而不再执行后面所有的命令，而是<code>||</code>操作符相当于将<code>cmd1-2</code>与<code>cmd3</code>连接成了<code>cmd1-2_3</code>，因为<code>cmd1-2</code>成功了，所以<code>cmd3</code>不再执行，但是<code>cmd1-2_3</code>相当于执行成功了</li><li>继续执行，发现是<code>&amp;&amp;</code>操作符，同样将<code>cmd1-2_3</code>与<code>cmd4</code>连接起来，记为<code>cmd1-2_3-4</code>，因为<code>cmd1-2_3</code>执行成功了，所以<code>cmd4</code>也被执行，但是<code>cmd4</code>执行失败了，所以<code>cmd1-2_3-4</code>相当于执行失败</li><li>继续执行，发现是<code>||</code>操作符，同样将<code>cmd1-2_3-4</code>与<code>cmd5</code>连成<code>cmd1-2_3-4_5</code>，因为<code>cmd1-2_3-4</code>执行失败，所以<code>cmd5</code>被执行</li></ul><p>可见，<code>shell</code>永远都是从左往右扫描执行，<code>&amp;&amp;</code>跟<code>||</code>会将前后两个命令连接起来，根据两种操作符的规则就可以知道多个连起来的命令是如何执行的了。</p><h2 id="符号"><a href="#符号" class="headerlink" title="#符号"></a><code>#</code>符号</h2><p>跟其它很多语言一样，<code>#</code>在<code>shell</code>里面用来注释。</p><h2 id="转义符号"><a href="#转义符号" class="headerlink" title="\转义符号"></a><code>\</code>转义符号</h2><p><code>\</code>符号可以用来转义一些特殊符号，如<code>$</code>，<code>#</code>等。</p><blockquote><p>特别指出的是，如果转义符号放在行末单独使用，则用来连接下一行。</p></blockquote><h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义跟引用"><a href="#定义跟引用" class="headerlink" title="定义跟引用"></a>定义跟引用</h3><p><code>shell</code>中也可以使用变量，变量不需要像其它语言一样需要预先申明。<code>shell</code>中赋值给一个不存在的变量就相当于定义了变量，如<code>name=&quot;Mr. Hao&quot;</code>，就定义了<code>name</code>变量，后续如果再对<code>name</code>赋值，就相当于改变改变量的值。与很多语言不同的是，<code>shell</code>中变量引用以<code>$</code>符号开头，后面跟变量的名字。如前面的变量，引用如下<code>echo &quot;$name&quot;</code>。<strong>需要注意的是，在<code>shell</code>中，变量名是大小写敏感的。</strong></p><p>在<code>shell</code>展开中会自动展开变量的引用，即便该变量处在双引号中。但是，如果变量引用在单引号中，<code>shell</code>不会对其进行解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># name=&quot;Mr. Hao&quot;</div><div class="line"># echo &quot;$name&quot;</div><div class="line">Mr. Hao</div><div class="line"># set -x</div><div class="line"># echo &apos;$name&apos;</div><div class="line">+ echo &apos;Mr. Hao&apos;</div><div class="line">$name</div></pre></td></tr></table></figure><h3 id="查找变量"><a href="#查找变量" class="headerlink" title="查找变量"></a>查找变量</h3><p>可以使用<code>set</code>命令来查找所定义的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># set | grep -E &apos;^name=&apos;</div><div class="line">name=&apos;Mr. Hao&apos;</div></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>与很多语言不同的是，在<code>shell</code>中定义的变量是可以删除的，使用<code>unset</code>命令删除定义的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># set | grep -E &apos;^name=&apos;</div><div class="line">name=&apos;Mr. Hao&apos;</div><div class="line"># unset name</div><div class="line"># set | grep -E &apos;^name=&apos;</div></pre></td></tr></table></figure><h3 id="export声明"><a href="#export声明" class="headerlink" title="export声明"></a><code>export</code>声明</h3><p>通常情况下，<code>shell</code>在执行命令的时候会为该命令创建子进程。如果希望将当前的变量作用到子进程，则需要将变量<code>export</code>声明，这种变量称之为环境变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=&quot;hello&quot;</div><div class="line"># export var2=&quot;world&quot;</div><div class="line"># bash</div><div class="line"># echo &quot;var1=$var1, var2=$var2&quot;</div><div class="line">var1=, var2=world</div></pre></td></tr></table></figure><p>其中，<code>bash</code>命令开启了一个新的<code>shell</code>，可见只有<code>export</code>声明的变量在新的<code>shell</code>中才是可见的。环境变量可以通过<code>env</code>命令列举出来，在后面一节会详细讲述。此外，如果需要将非<code>export</code>变量重新声明为<code>export</code>变量，则只需要用<code>export</code>重新声明一下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=hello</div><div class="line"># env | grep var1</div><div class="line"># export var1</div><div class="line"># env | grep var1</div><div class="line">var1=hello</div></pre></td></tr></table></figure><h3 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a><code>env</code>命令</h3><p>如果需要查看当前<code>shell</code>中有哪些<code>export</code>声明的变量，可以使用<code>env</code>命令，该命令会列出当前所有<code>export</code>声明的变量。请注意与<code>set</code>命令的区别，<code>set</code>命令会列出所有的变量，包括哪些不是<code>export</code>声明的变量。通常，我们把<code>env</code>命令输出的变量称之为<code>环境变量</code>。</p><p>此外，<code>env</code>也常用来为子<code>shell</code>预先定义一些临时变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=&quot;hello&quot;</div><div class="line"># env var1=&quot;tmp&quot; bash -c &apos;echo &quot;$var1&quot;&apos;</div><div class="line">tmp</div><div class="line"># echo $var1</div><div class="line">hello</div></pre></td></tr></table></figure><p>其中，用<code>env</code>命令定义了临时变量<code>var1</code>，然后<code>bash</code>命令开启了一个子<code>shell</code>，并在子<code>shell</code>中执行了<code>echo &quot;$var1&quot;</code>命令。可见，输出了定义的临时变量，在命令结束后，又回到之前的<code>shell</code>，输出的也是之前<code>shell</code>中定义的值。当然，在使用<code>env</code>定义临时变量的时候，为了方便，通常我们可以省略<code>env</code>命令，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=&quot;hello&quot;</div><div class="line"># var1=&quot;tmp&quot; bash -c &apos;echo &quot;$var1&quot;&apos;</div><div class="line">tmp</div><div class="line"># echo $var1</div><div class="line">hello</div></pre></td></tr></table></figure><p>另外，<code>env</code>命令还有一种常用的用法，就是用来开启一个干净的子<code>shell</code>，即在子<code>shell</code>中不继承所有的变量，即便这些变量在之前的<code>shell</code>中采用<code>export</code>声明，此时<code>env</code>命令需要加入<code>-i</code>的参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># export var1=&quot;hello world&quot;</div><div class="line"># bash -c &apos;echo &quot;var1=$var1&quot;&apos;</div><div class="line">var1=hello world</div><div class="line"># env -i bash -c &apos;echo &quot;var1=$var1&quot;&apos;</div><div class="line">var1=</div></pre></td></tr></table></figure><p>可见，使用<code>env -i</code>之后，即便<code>var1</code>被<code>export</code>声明，但是在子<code>shell</code>中也没有被继承。</p><h3 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h3><p>在前面章节，我们知道<code>shell</code>采用<code>$</code>符号引用变量，在<code>$</code>符号后紧跟变量的名字。而<code>shell</code>在提取变量名字的时候一般以非字母数字（non-alphanumeric）为边界，这有时候就会产生问题，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># prefix=Super</div><div class="line"># echo Hello $prefixman and $prefixgirl</div><div class="line">Hello  and</div></pre></td></tr></table></figure><p>可见，<code>shell</code>并不能提取我们定义的变量<code>prefix</code>，因为其后并没有非字母数字的字符为界。这种情况下，我们可以使用<code>{}</code>将变量名保护起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># prefix=Super</div><div class="line"># echo Hello $&#123;prefix&#125;man and $&#123;prefix&#125;girl</div><div class="line">Hello Superman and Supergirl</div></pre></td></tr></table></figure><h3 id="非绑定（unbound）变量"><a href="#非绑定（unbound）变量" class="headerlink" title="非绑定（unbound）变量"></a>非绑定（unbound）变量</h3><p>所谓非绑定（unbound）变量其实指的是没有预先定义的变量，或者说不存在的变量。默认情况下，<code>shell</code>在解释这种变量的时候会以空字符串替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># echo $unbound_var</div></pre></td></tr></table></figure><p>如果需要<code>shell</code>在这种情况下报错，可以配置<code>shell</code>选项<code>set -o nounset</code>，或者简写为<code>set -u</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># echo $unbound_var</div><div class="line">bash: unbound_var: unbound variable</div><div class="line"># set +u</div><div class="line"># echo $unbound_var</div></pre></td></tr></table></figure><p>当然，由例子中可以看到，要取消该配置，可以相应的设置<code>set +o nounset</code>，或者简写为<code>set +u</code>。</p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p>在<code>shell</code>中预定义了很多特殊的变量，这一节咱们来说一下常见的几个变量。</p><h3 id="PS1变量"><a href="#PS1变量" class="headerlink" title="$PS1变量"></a><code>$PS1</code>变量</h3><p>在<code>shell</code>终端输入命令时，咱们总是可以看到在输入行首总是会有提示符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mrhao:~$</div></pre></td></tr></table></figure><p>其中，<code>mrhao:~$</code>就是提示符，这个字串实际上是由<code>shell</code>变量<code>$PS1</code>决定的。如果咱们改变一下该变量的值，提示符也会相应的改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mrhao:~$ PS1=&quot;hello &gt; &quot;</div><div class="line">hello &gt; echo &quot;PS1 value is &apos;$PS1&apos;&quot;</div><div class="line">PS1 value is &apos;hello &gt; &apos;</div><div class="line">hello &gt;</div></pre></td></tr></table></figure><p>为了方便在提示符中显示系统的某些实时信息，<code>$PS1</code>变量定义了一些特殊的字符：</p><p>|——+——————–|<br>| 字符 | 说明               |<br>|——+——————–|<br>| \w   | 表示工作目录       |<br>| \u   | 表示用户名         |<br>| \h   | 表示系统的hostname |<br>|——+——————–|</p><p>当然，这里只列举了几个，详细的可以查看Linux手册。另外，<code>$PS1</code>中还可以对对其中不同部分采用不同颜色显示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># RED=&apos;\[\033[01;31m\]&apos;</div><div class="line"># WHITE=&apos;\[\033[01;00m\]&apos;</div><div class="line"># GREEN=&apos;\[\033[01;32m\]&apos;</div><div class="line"># BLUE=&apos;\[\033[01;34m\]&apos;</div><div class="line"># PS1=&quot;$GREEN\u$WHITE@$BLUE\h$WHITE\w\$ &quot;</div><div class="line">mrhao@mrhao-host~$ echo &quot;$PS1&quot;</div><div class="line">\[\033[01;32m\]\u\[\033[01;00m\]@\[\033[01;34m\]\h\[\033[01;00m\]\w$</div></pre></td></tr></table></figure><h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="$PATH变量"></a><code>$PATH</code>变量</h3><p>当我们在Linux的terminal里面输入命令的时候，<code>shell</code>需要在一系列的目录中查找输入的命令，如果没有查找到会直接报<code>command not found</code>的错误。而这些查找的目录就定义在<code>$PATH</code>变量中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo $PATH</div><div class="line">/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</div></pre></td></tr></table></figure><p>其中，每个目录以<code>:</code>隔开，如果需要增加目录，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># PATH=$PATH:/opt/local/bin</div><div class="line"># echo $PATH</div><div class="line">/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/opt/local/bin</div></pre></td></tr></table></figure><blockquote><p>加入新的路径的时候请务必带上之前的路径，<code>$PATH:&lt;new path&gt;</code>否则，很多默认的系统路径将被覆盖，导致很多命令失效。</p></blockquote><p>特别注意的是，<code>$PATH</code>变量中目录的顺序是很重要的，如果<code>shell</code>在前面的目录中找到了命令，则不会查找后面的目录。如果你想把某个重名的命令优先执行，就需要把它对应的目录放在<code>$PATH</code>的前面。</p><h3 id="网络代理变量"><a href="#网络代理变量" class="headerlink" title="网络代理变量"></a>网络代理变量</h3><p>在Linux系统中，很多时候我们需要访问外部网络，比如使用<code>curl</code>命令下载文件等等。而有的时候，访问访问外部网络咱们需要设置代理，在Linux系统中，使用网络代理非常简单，只要配置几个变量即可：</p><p>|————-+————————————————————————-|<br>| 变量        | 说明                                                                    |<br>|————-+————————————————————————-|<br>| http_proxy  | 设置访问<code>http</code>请求所需要的代理，如<code>http_proxy=http://10.10.10.100:80</code>   |<br>| https_proxy | 设置访问<code>https</code>请求所需要的代理，如<code>https_proxy=http://10.10.10.100:80</code> |<br>| ftp_proxy   | 设置访问<code>ftp</code>请求所需要的代理，如<code>ftp_proxy=http://10.10.10.100:80</code>     |<br>| no_proxy    | 设置哪些域名或者IP不需要走代理，如<code>no_proxy=localhost,127.0.0.1</code>        |<br>|————-+————————————————————————-|</p><h3 id="PWD变量"><a href="#PWD变量" class="headerlink" title="$PWD变量"></a><code>$PWD</code>变量</h3><p><code>PWD</code>变量是一个由<code>shell</code>自动设置的变量，其值表示当前目录的绝对路径，与命令<code>pwd</code>输出相同。</p><h1 id="shell嵌入与shell选项"><a href="#shell嵌入与shell选项" class="headerlink" title="shell嵌入与shell选项"></a><code>shell</code>嵌入与<code>shell</code>选项</h1><h2 id="shell嵌入（shell-embedding）"><a href="#shell嵌入（shell-embedding）" class="headerlink" title="shell嵌入（shell embedding）"></a><code>shell</code>嵌入（shell embedding）</h2><p><code>shell</code>可以嵌入在同一个命令行中，也就是<code>shell</code>在扫描解释命令行的时候，可能会从当前的<code>shell</code>进程中<code>fork</code>出一个新的<code>shell</code>进程，并将有关命令放在新进程中运行。如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=hello</div><div class="line"># echo $(var1=world; echo $var1)</div><div class="line">world</div><div class="line"># echo $var1</div><div class="line">hello</div></pre></td></tr></table></figure><p>如其中<code>$()</code>便开启了一个新的<code>shell</code>进程，或者成为子<code>shell</code>，并在此<code>shell</code>中运行命令<code>var1=world; echo $var1</code>，此时输出的是子<code>shell</code>中定义的<code>var1</code>。当命令结束后，子<code>shell</code>进程退出，并将输出的结果<code>world</code>返回给之前的<code>shell</code>（或者父<code>shell</code>）的<code>echo</code>命令，父<code>shell</code>最后输出<code>world</code>。而且，在子<code>shell</code>中定义相同的<code>var1</code>变量并不会改变父<code>shell</code>中的变量。</p><p><strong><em>特别注意的是，因为子<code>shell</code>是<code>fork</code>出来的进程，根据Linux进程<code>fork</code>的特点，子进程将共享父进程的数据空间，而只在写的时候拷贝新的数据空间，因此，创建出来的子<code>shell</code>是会继承所有父<code>shell</code>的变量，不论该变量是否被<code>export</code>声明</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># var1=hello</div><div class="line"># var2=&quot;$(echo $var1 world)&quot;</div><div class="line"># echo $var2</div><div class="line">hello world</div></pre></td></tr></table></figure><p>可见，虽然<code>var1</code>变量没有<code>export</code>声明，但是在子<code>shell</code>中还是可见的。这点与使用<code>bash -c</code>开启的<code>shell</code>是不同的。</p><p>用<code>$()</code>可以将子<code>shell</code>嵌入到命令行中，当然，<code>$()</code>是可以嵌套使用的，这样可以用来在子<code>shell</code>中开启它的子<code>shell</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># A=shell</div><div class="line"># echo $C$B$A $(B=sub;echo $C$B$A; echo $(C=sub;echo $C$B$A))</div><div class="line">shell subshell subsubshell</div></pre></td></tr></table></figure><h3 id="反引号（backticks）"><a href="#反引号（backticks）" class="headerlink" title="反引号（backticks）"></a>反引号（backticks）</h3><p>在上面我们可以通过<code>$()</code>将子<code>shell</code>嵌入命令行中，为了方便，我们同样可以用反引号<code>` </code>将子<code>shell</code>嵌入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var1=hello</div><div class="line"># echo `var1=world; echo $var1`</div><div class="line">world</div><div class="line"># echo $var1</div><div class="line">hello</div></pre></td></tr></table></figure><p>但是，使用反引号不能够嵌套子<code>shell</code>，因此如果需要嵌套子<code>shell</code>时，只能使用<code>$()</code>。</p><blockquote><p>反引号跟单引号是本质的不同的，单引号与双引号一样，用来将连续的字串作为整体引起来，只不过单引号中将不执行变量的引用解析，而反引号则是嵌入子<code>shell</code>。</p></blockquote><h2 id="shell选项"><a href="#shell选项" class="headerlink" title="shell选项"></a><code>shell</code>选项</h2><p>其实在前面咱们已经使用了不少<code>shell</code>的选项，如<code>set -u</code>在变量不存在是报错，<code>set -x</code>将<code>shell</code>展开的结果显示出来等。此外，可以才用<code>echo $-</code>将当期设置的<code>shell</code>选项打印出来。</p><h1 id="shell历史记录"><a href="#shell历史记录" class="headerlink" title="shell历史记录"></a><code>shell</code>历史记录</h1><p>在<code>shell</code>中执行命令的时候，<code>shell</code>会将最近的命令使用历史记录下来，这样你可以很方便的查看最近做了什么操作。</p><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><p>命令<code>history</code>可以用来查看<code>shell</code>的历史记录，里面记录了你最近输入的所有命令。当然，很多时候你更加关心最近的几个命令，你可以使用<code>history 10</code>来显示最近的10个命令。另外，<code>shell</code>通常还会将最近的历史记录写在<code>~/.bash_history</code>文件中，因此查看该文件同样可以查看历史记录。</p><h2 id="执行历史的命令"><a href="#执行历史的命令" class="headerlink" title="执行历史的命令"></a>执行历史的命令</h2><p><code>shell</code>提供了很多高级用法使得你可以很方便的执行以前执行过的命令。</p><p>首先，咱们先显示一下过去的10个命令，可以看到每个命令前面都有其对应的序号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># history 10</div><div class="line"> 1000  history</div><div class="line"> 1001  history 10</div><div class="line"> 1002  echo &quot;hello world&quot;</div><div class="line"> 1003  ls -l</div><div class="line"> 1004  ps -ef | grep named</div><div class="line"> 1005  env | grep http</div><div class="line"> 1006  grep hello /var/log/messages</div><div class="line"> 1007  tmux ls</div><div class="line"> 1008  find . -name &quot;hello&quot;</div><div class="line"> 1009  history 10</div></pre></td></tr></table></figure><p>下面列举比较常用的<code>shell</code>重复执行历史记录中命令的方法：</p><p>|———–+——————————————————————————————————-|<br>| 命令      | 说明                                                                                                  |<br>|———–+——————————————————————————————————-|<br>| !!        | 在<code>shell</code>中输入两个感叹号会执行上一个命令                                                             |<br>| !keyword  | 输入一个感叹号后跟关键字，会搜索历史记录中最先以该关键字开始的命令。如<code>!find</code>会执行序号为1008的命令。 |<br>| !?keyword | 执行历史记录中第一个包括keyword关键字的命令                                                           |<br>| !n        | 其中n代表历史记录中的序号，表示执行序号为n的命令。                                                    |<br>| !-n       | 执行倒数第n个命令，如<code>!-1</code>其实就相当于<code>!!</code>                                                            |<br>| cmd!<em>     | 执行命令<code>cmd</code>，其中`!</em>`会以上一条命令的所有参数替代                                                   |<br>|———–+——————————————————————————————————-|</p><p>另外，对于<code>!keyword</code>的用法，还有一个高级功能，你可以将符合该条件的命令进行改造后执行，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># echo &quot;test1&quot;</div><div class="line">test1</div><div class="line"># !ec:s/1/2/</div><div class="line">echo &quot;test2&quot;</div><div class="line">test2</div></pre></td></tr></table></figure><p>其中，<code>:s/1/2/</code>将命令<code>echo &quot;test1&quot;</code>替换成<code>echo &quot;test2&quot;</code>然后执行了。对于<code>cmd!*</code>，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ctt /etc/passwd | cut -d: -f1</div><div class="line">-bash: ctt: command not found</div><div class="line"># cat !*</div><div class="line">cat /etc/passwd | cut -d: -f1</div><div class="line">root</div><div class="line">bin</div><div class="line">daemon</div><div class="line">adm</div><div class="line">...</div></pre></td></tr></table></figure><h2 id="搜索历史记录"><a href="#搜索历史记录" class="headerlink" title="搜索历史记录"></a>搜索历史记录</h2><p>在<code>shell</code>终端中按Ctrl-r会打开<code>shell</code>的搜索模式，在改模式下输入关键字会显示最近包含改关键字的命令，再按一下Ctrl-r会继续显示前面一条符合条件的命令，找到你需要的命令后回车就可以执行改命令了。</p><h2 id="修改历史记录的有关配置"><a href="#修改历史记录的有关配置" class="headerlink" title="修改历史记录的有关配置"></a>修改历史记录的有关配置</h2><p>有多个配置可以用来改变历史记录的有关信息，通常都是通过有关环境变量来配置：</p><p>|—————+——————————————————————————————–|<br>| 环境变量      | 说明                                                                                       |<br>|—————+——————————————————————————————–|<br>| $HISTSIZE     | 这个变量用来配置<code>shell</code>应该保持多少行的历史记录，在很多发行版本中，默认值一般为500或者1000 |<br>| $HISTFILE     | 这个变量用来配置历史记录文件存放的位置，通常来讲，默认路径为<code>~/.bash_history</code>              |<br>| $HISTFILESIZE | 这个变量用来配置历史记录文件可以存放多少行的历史记录                                       |<br>|—————+——————————————————————————————–|</p><h2 id="阻止记录某些命令"><a href="#阻止记录某些命令" class="headerlink" title="阻止记录某些命令"></a>阻止记录某些命令</h2><p>在有些时候，我们并不想把某些命令记录在历史记录中，比如有的命令里面包括了敏感信息如密码等。在新版本的<code>shell</code>中，通常我们可以在输入的命令前面加入空格，这样<code>shell</code>就不会记录这样的命令，当然，如果你的发行版本默认并不支持，你可以配置环境变量来打开这个功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> HISTIGNORE=<span class="string">"[ \t]*"</span></div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># history 5</div><div class="line"> 1023  ls -l</div><div class="line"> 1024  echo &quot;&quot;</div><div class="line"> 1025  history 5</div><div class="line"> 1026  ls</div><div class="line"> 1027  history 5</div><div class="line">#  echo &quot;password=123456&quot;</div><div class="line">password=123456</div><div class="line"># history 5</div><div class="line"> 1025  history 5</div><div class="line"> 1026  ls</div><div class="line"> 1027  history 5</div><div class="line"> 1028   echo &quot;password=123456&quot;</div><div class="line"> 1029  history 5</div><div class="line"># export HISTIGNORE=&quot;[ \t]*&quot;</div><div class="line"># history 5</div><div class="line"> 1027  history 5</div><div class="line"> 1028   echo &quot;password=123456&quot;</div><div class="line"> 1029  history 5</div><div class="line"> 1030  export HISTIGNORE=&quot;[ \t]*&quot;</div><div class="line"> 1031  history 5</div><div class="line">#  echo &quot;password=123456&quot;</div><div class="line">password=123456</div><div class="line"># history 5</div><div class="line"> 1027  history 5</div><div class="line"> 1028   echo &quot;password=123456&quot;</div><div class="line"> 1029  history 5</div><div class="line"> 1030  export HISTIGNORE=&quot;[ \t]*&quot;</div><div class="line"> 1031  history 5</div></pre></td></tr></table></figure><p>可见，在设置<code>$HISTIGNORE</code>变量之后，在前面加了空格的命令将不再记录。这在保护敏感信息的时候非常有用。</p><h1 id="文件匹配-File-Globbing"><a href="#文件匹配-File-Globbing" class="headerlink" title="文件匹配(File Globbing)"></a>文件匹配(File Globbing)</h1><p>文件匹配(File Globbing)又成为动态文件名生成，用它可以非常方便的在<code>shell</code>中输入文件名。</p><h2 id="星号"><a href="#星号" class="headerlink" title="*星号"></a><code>*</code>星号</h2><p><code>*</code>星号在<code>shell</code>中用来匹配任意数量的字符，比如文件名<code>File*.mp4</code>，将匹配以<code>File</code>开头，<code>.mp4</code>结尾的任何文件名。<code>shell</code>在扫描解释命令的时候会自动去查找符合该匹配的所有文件或目录。当然，你也可以只用<code>*</code>来匹配所有的文件及目录，但请注意，只使用<code>*</code>跟不带<code>*</code>还是有所区别的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ls</div><div class="line">definition.yaml  example  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py</div><div class="line"># ls *</div><div class="line">definition.yaml  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py</div><div class="line"></div><div class="line">example:</div><div class="line">testcase</div></pre></td></tr></table></figure><p>可见，带上<code>*</code>后不仅把当前目录的所有文件及目录显示出来，而且还把目录下的内容显示出来了。</p><h2 id="问号"><a href="#问号" class="headerlink" title="?问号"></a><code>?</code>问号</h2><p>问号用来匹配一个字符，如<code>File?.mp4</code>可以匹配<code>File1.mp4</code>。</p><h2 id="方括号"><a href="#方括号" class="headerlink" title="[]方括号"></a><code>[]</code>方括号</h2><p><code>[]</code>方括号也用来匹配一个字符，但是在括号里面可以指定一个字符集用来限定匹配的字符必须在该字符集内，字符集里面的字符顺序没有关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ls</div><div class="line">file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc</div><div class="line"># ls File[5A]</div><div class="line">FileA</div><div class="line"># ls File[A5]</div><div class="line">FileA</div><div class="line"># ls File[A5][5b]</div><div class="line">File55</div></pre></td></tr></table></figure><p>如果需要匹配不在某个字符集里面的字符，可以在<code>[]</code>第一个字符加入<code>!</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ls file[!5]*</div><div class="line">file1  file2  file3  fileab  fileabc</div></pre></td></tr></table></figure><p>特别的，为了方便，<code>[]</code>中可以使用<code>-</code>来定义一些连续的字符集（Range匹配），常用的这类字符集包括：</p><p>|——–+——————–|<br>| 字符集 | 说明               |<br>|——–+——————–|<br>| 0-9    | 表示数字字符集     |<br>| a-z    | 表示小写字母字符集 |<br>| A-Z    | 表示大写字母字符集 |<br>|——–+——————–|</p><p>当然，你也不必要把所有范围都包括在内，如<code>[a-d]</code>可以用来限定从<code>a</code>到<code>d</code>的小写字母集。另外，用<code>-</code>连起来的字符集还可以跟其它字符集一起使用，如<code>[a-d_]</code>表示<code>a</code>到<code>d</code>的小写字母加上<code>_</code>所组成的字符集。</p><ul><li><p>Range匹配的大小写问题</p><p>  对于<code>[]</code>的Range匹配，还有一点很重要。在很多发行版本中，默认情况下，<code>[]</code>的Range匹配是忽略大小写的</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ls</div><div class="line">Test1  test2</div><div class="line"># ls [a-z]*</div><div class="line">Test1  test2</div><div class="line"># ls [A-Z]*</div><div class="line">Test1  test2</div><div class="line"># ls [t]*</div><div class="line">test2</div><div class="line"># ls [T]*</div><div class="line">Test1</div></pre></td></tr></table></figure><blockquote><p>注意，是<code>[]</code>的Range匹配会忽略大小写，而如果不是Range匹配还是大小写敏感的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; # ls</div><div class="line">&gt; Test1  test2</div><div class="line">&gt; # ls [T]*</div><div class="line">&gt; Test1</div><div class="line">&gt; # ls [t]*</div><div class="line">&gt; test2</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>  如果需要大小写敏感，可以设置环境变量<code>LC_ALL</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># LC_ALL=C</div><div class="line"># ls [a-z]*</div><div class="line">test2</div><div class="line"># ls [A-Z]*</div><div class="line">Test1</div></pre></td></tr></table></figure><p>  当然，请务必注意，<code>LC_ALL</code>的会改变当前的语言环境，还请慎重使用，建议只在临时的子<code>shell</code>中使用。</p></li></ul><h2 id="阻止文件匹配-File-Globbing"><a href="#阻止文件匹配-File-Globbing" class="headerlink" title="阻止文件匹配(File Globbing)"></a>阻止文件匹配(File Globbing)</h2><p>有时候我们就是需要输出<code>*</code>等匹配符号，这个时候就需要阻止<code>shell</code>做相应的匹配。可以使用转义符号<code>\</code>来做到这点，或者将匹配符号放在引号中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># echo *</div><div class="line">Test1 test2</div><div class="line"># echo \*</div><div class="line">*</div><div class="line"># echo &apos;*&apos;</div><div class="line">*</div><div class="line"># echo &quot;*&quot;</div><div class="line">*</div></pre></td></tr></table></figure><h1 id="shell快捷键"><a href="#shell快捷键" class="headerlink" title="shell快捷键"></a>shell快捷键</h1><p><code>shell</code>中支持非常多的快捷键，可以非常方便我们输入命令：</p><p>|——–+—————————————————————————|<br>| 快捷键 | 说明                                                                      |<br>|——–+—————————————————————————|<br>| Ctrl-d | 表示<code>EOF</code>的意思，在shell终端中输入该快捷键会退出该终端                    |<br>| Ctrl-z | 该快捷键用来暂停一个在shell终端中正在执行的进程，暂停后可以用<code>fg</code>命令恢复 |<br>| Ctrl-a | 输入命令时跳到行首                                                        |<br>| Ctrl-e | 跳到行尾                                                                  |<br>| Ctrl-k | 删除从光标到行尾的部分                                                    |<br>| Ctrl-y | 粘贴刚刚删除的部分                                                        |<br>| Ctrl-w | 删除从光标至其左边第一个空格处                                            |<br>|——–+—————————————————————————|</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先，咱们来了解一下，什么是&lt;code&gt;Shell&lt;/code&gt;。操作系统内核给我们提供了各种接口，同时也提供了各种用户层的库，理论上我们基于这些可以编写程序实现各种我们想要的功能，不过问题是，咱们不可能做什么事情都要重新编写程序，这样使用起来也太困难了。因此，操作系统（包括Linux）通常都会引入一个&lt;code&gt;Shell&lt;/code&gt;这样的特殊程序，这个程序会接受输入的命令然后执行，并可能将执行结果呈现出来。总结来说，&lt;code&gt;Shell&lt;/code&gt;是一个从输入设备或者文件读取命令，并且解释、执行的用户态程序。&lt;/p&gt;
&lt;p&gt;在Linux系统中，通常使用的&lt;code&gt;Shell&lt;/code&gt;程序包括有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sh (Bourne Shell)&lt;/li&gt;
&lt;li&gt;Bash (Bourne Again Shell)&lt;/li&gt;
&lt;li&gt;Csh (C Shell)&lt;/li&gt;
&lt;li&gt;Ksh (Korn Shell)
    
    </summary>
    
      <category term="Linux" scheme="http://github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="study" scheme="http://github.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习（二）文件系统结构</title>
    <link href="http://github.com/2018/04/14/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>http://github.com/2018/04/14/Linux学习（二）文件系统结构/</id>
    <published>2018-04-14T14:57:29.000Z</published>
    <updated>2018-04-14T15:02:36.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>多数Linux发行版本都是遵循<code>文件系统结构标准（Filesystem Hierarchy Standard, 简称FHS）</code>，可以在<a href="http://www.pathname.com/fhs/" target="_blank" rel="external">这里</a>找到该标准。本文对Linux的文件系统结构进行简单的介绍。</p><h1 id="根目录"><a href="#根目录" class="headerlink" title="根目录/"></a>根目录<code>/</code></h1><p>所有的Linux系统都有根目录，由<code>/</code>表示。Linux系统的所有内容都在该目录下。</p><h1 id="二进制目录"><a href="#二进制目录" class="headerlink" title="二进制目录"></a>二进制目录</h1><p>|—————-+——————————————————————————————————————–|<br>| 目录           | 说明                                                                                                               |<br>|—————-+——————————————————————————————————————–|<br>| /bin           | 包括了可执行的二进制文件，通常这些二进制文件可以被所有用户访问。FHS规定，该目录至少包括<code>/bin/cat</code>跟<code>/bin/date</code>文件 |<br>| /sbin          | 包括了系统的二进制文件，通过需要root权限，用来配置系统                                                             |<br>| /lib           | 包括了<code>/bin</code>所依赖的库                                                                                             |<br>| /lib/modules   | Linux将从<code>/lib/modules/$kernel-version/</code>目录下载入内核模块                                                         |<br>| /lib32和/lib64 | 顾名思义，分别存放不同位数的库                                                                                     |<br>| /opt           | 该目录用来存放一些可选的软件，通常情况下，很多第三方的客户软件会选择安装在该目录下                                 |<br>|—————-+——————————————————————————————————————–|</p><a id="more"></a><h1 id="配置文件目录"><a href="#配置文件目录" class="headerlink" title="配置文件目录"></a>配置文件目录</h1><p>|—————-+————————————————————————————————————————–|<br>| 目录           | 说明                                                                                                                     |<br>|—————-+————————————————————————————————————————–|<br>| /boot          | 顾名思义，用来存放系统启动的配置文件，如grub引导的配置文件<code>/boot/grub/grub.cfg</code>                                          |<br>| /etc           | 几乎大部分配置文件都放在改目录下。历史上<code>etc</code>的全称是<code>etcetera</code>，不过，现在一般认为是<code>Editable Text Configuration</code>的缩写 |<br>| /etc/init.d    | 存放daemon启动、停止等的脚本文件。不过在引入systemd之后，启动脚本有所变化                                                |<br>| /etc/skel      | 存放创建新用户之后所需的配置文件的模板，如<code>.bashrc</code>文件，默认会从该目录拷贝到用户目录                                    |<br>| /etc/sysconfig | 一般出现在RedHat系列的Linux系统中，存放系统有关配置，如IP的配置文件等                                                    |<br>|—————-+————————————————————————————————————————–|</p><h1 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h1><p>|——–+—————————————————————————————————-|<br>| 目录   | 说明                                                                                               |<br>|——–+—————————————————————————————————-|<br>| /home  | 当创建一个新用户的时候，默认情况下，系统会为用户创建一个<code>/home/&lt;username&gt;</code>的目录用来存放个人数据。 |<br>| /root  | 该目录被很多Linux系统用来存放root用户的个人数据                                                    |<br>| /srv   | 可以被解释为<code>served by your system</code>。FHS允许<code>rsync</code>，<code>ftp</code>，<code>www</code>等数据存放在改目录                |<br>| /media | 该目录通常被用来挂载可移除设备，如CD-ROM，U盘等                                                    |<br>| /mnt   | 根据FHS，该目录通常被用来作为短期的挂载点                                                          |<br>| /tmp   | 该目录用来存放一些短期的文件，<strong><em>不要再该目录下存放重要文件，该目录下的文件有可能会被系统回收</em></strong>   |<br>|——–+—————————————————————————————————-|</p><h1 id="内存目录"><a href="#内存目录" class="headerlink" title="内存目录"></a>内存目录</h1><p>Linux系统中，几乎所有的东西都被映射成文件，文件有的是对应着硬盘、设备（CD-ROM等）等，有的则被Linux映射到内存中。这一节介绍映射到内存中的目录。</p><h2 id="dev目录"><a href="#dev目录" class="headerlink" title="/dev目录"></a>/dev目录</h2><p><code>/dev</code>目录映射了各种设备文件，这些文件由系统启动的时候扫描硬件生成。</p><h3 id="物理设备文件"><a href="#物理设备文件" class="headerlink" title="物理设备文件"></a>物理设备文件</h3><p>物理设备包括很多种，如硬盘，CD-ROM等。不同的物理设备映射为<code>/dev</code>目录下不同的文件。如SATA/SCSI设备或USB通常被映射为<code>/dev/sd*</code>，其中<code>*</code>可以为<code>[a-z]</code>中的任意字符；而IDE设备通常被映射为<code>/dev/hd*</code>，其中<code>*</code>为<code>[a-z]</code>中任意字符。</p><h3 id="dev-tty跟-dev-pts"><a href="#dev-tty跟-dev-pts" class="headerlink" title="/dev/tty跟/dev/pts"></a>/dev/tty跟/dev/pts</h3><p>首先需要搞清楚<code>tty</code>设备跟<code>pts</code>设备的区别。这两者都是终端设备，所谓终端设备通常指的是能够接受命令输入，并可能同时能够输出的设备，但是这两者是有本质的不同的：</p><ul><li><p>tty设备</p><p>  <code>tty</code>是<code>Teletype</code>的简称，表示原生的终端设备，通常指的是物理终端设备如串口，键鼠接口等，以及系统内核模拟的终端设备。</p></li><li><p>pts设备</p><p>  <code>pts</code>是<code>Pseudo Terminal Slave</code>的简称，表示伪终端设备，通常由应用进程模拟出来，如ssh开启的终端等。</p></li></ul><p><code>tty</code>设备通常被映射为<code>/dev/tty*</code>，其中<code>*</code>代表数字，如<code>/dev/tty1</code>等。而<code>pts</code>设备被映射为<code>/dev/pts/*</code>，其中<code>*</code>表示数字，如<code>/dev/pts/1</code>。</p><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h3><p>该文件在Linux中有着特殊的意义，是一个只有输入的文件，且文件有无限的大小，你不能从该文件读出任何东西，任何写入的内容逻辑上相当于消失了。从实现的角度，实际上任何写入的内容都被系统丢弃了。</p><h2 id="proc目录"><a href="#proc目录" class="headerlink" title="/proc目录"></a>/proc目录</h2><p>该目录用来记录内核以及内核进程的实时信息，可以通过它轻而易举的实现对内核状态的获取甚至改变。</p><p>|——————+——————————————————————————————————————-|<br>| 目录             | 说明                                                                                                              |<br>|——————+——————————————————————————————————————-|<br>| /proc/<id>       | 几乎每个进程都会在该目录下有映射的文件<code>/proc/*</code>，其中<code>&lt;id&gt;</code>代表进程的ID。该目录记录的该进程的几乎所有的状态信息。 |<br>| /proc/cpuinfo    | 记录了系统的CPU信息，通常通过该文件可以知道系统有多少个CPU（核数）。                                              |<br>| /proc/meminfo    | 记录了系统的内存信息，可以通过它知道系统有多少内存                                                                |<br>| /proc/sys        | 在<code>/proc</code>目录下的绝大部分文件都是只读的文件，但是在该目录下有些文件是可写的，可以通过它们改变内核状态             |<br>| /proc/interrupts | 记录了当前系统的中断信息                                                                                          |<br>| /proc/kcore      | 这个文件代表了系统的物理内存，其大小就是物理内存的大小，因此千万不要用<code>cat</code>来试图显示该文件内容                   |<br>|——————+——————————————————————————————————————-|</id></p><h1 id="usr目录"><a href="#usr目录" class="headerlink" title="/usr目录"></a>/usr目录</h1><p><code>/usr</code>目录估计是被误解最多的目录，一般大家都以为它是<code>user</code>的简写，感觉应该存放的是用户相关的东西，但是实际上完全不是这样。它其实是<code>Unix System Resources</code>的简写，表示Unix系统资源。通常情况下，该目录以只读的权限被挂载。</p><p>|————–+————————————————————————————————————-|<br>| 目录         | 说明                                                                                                        |<br>|————–+————————————————————————————————————-|<br>| /usr/bin     | 很多命令都存放在这个目录下面，事实上，在Centos跟Solaris系统中，<code>/bin</code>目录实际上只是一个软连接，连接到此目录 |<br>| /usr/include | 存放大量的头文件，可能会被C代码引用                                                                         |<br>| /usr/lib     | 存放库文件，同样，在Centos跟Solaris系统中，<code>/lib</code>其实就是软连接到此目录                                     |<br>| /usr/lib64   | 存放64位的库文件，在Centos中，<code>/lib64</code>也是软连接到此目录                                                    |<br>| /usr/sbin    | 很多daemon程序都是放在此目录下，在Centos中，<code>/sbin</code>也是软连接到此目录                                       |<br>| /usr/local   | 此目录通常用来安装一些本地的应用                                                                            |<br>| /usr/share   | 此目录通常用来存放各种体系无关的数据。<code>/usr/share/man</code>就是用来存放<code>man</code>命令用到的帮助文档                   |<br>| /usr/src     | 此目录通常存放内核的代码文件                                                                                |<br>|————–+————————————————————————————————————-|</p><h1 id="var目录"><a href="#var目录" class="headerlink" title="/var目录"></a>/var目录</h1><p><code>/var</code>目录用来存放可变的数据，如日志，数据库文件等。</p><p>|——————-+————————————————————————————————————-|<br>| 目录              | 说明                                                                                                        |<br>|——————-+————————————————————————————————————-|<br>| /var/log          | 此目录用来存放各种日志文件，包括系统跟应用的日志                                                            |<br>| /var/log/messages | 在RedHat系列系统中，此文件用来记录系统刚刚发生的事情。在Debian和Ubuntu系统中，对应的文件是<code>/var/log/syslog</code> |<br>| /var/cache        | 此目录存放很多应用的缓存数据，如<code>yum</code>命令可能会缓存部分数据在此目录                                         |<br>| /var/spool        | 一般情况下，该目录会存放邮件cron任务等数据                                                                  |<br>| /var/lib          | 通常此目录下会存放应用的状态信息，如<code>/var/lib/mysql</code>存放<code>mysql</code>数据库，<code>/var/lib/docker</code>存放<code>docker</code>的数据  |<br>|——————-+————————————————————————————————————-|</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;多数Linux发行版本都是遵循&lt;code&gt;文件系统结构标准（Filesystem Hierarchy Standard, 简称FHS）&lt;/code&gt;，可以在&lt;a href=&quot;http://www.pathname.com/fhs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;找到该标准。本文对Linux的文件系统结构进行简单的介绍。&lt;/p&gt;
&lt;h1 id=&quot;根目录&quot;&gt;&lt;a href=&quot;#根目录&quot; class=&quot;headerlink&quot; title=&quot;根目录/&quot;&gt;&lt;/a&gt;根目录&lt;code&gt;/&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;所有的Linux系统都有根目录，由&lt;code&gt;/&lt;/code&gt;表示。Linux系统的所有内容都在该目录下。&lt;/p&gt;
&lt;h1 id=&quot;二进制目录&quot;&gt;&lt;a href=&quot;#二进制目录&quot; class=&quot;headerlink&quot; title=&quot;二进制目录&quot;&gt;&lt;/a&gt;二进制目录&lt;/h1&gt;&lt;p&gt;|—————-+——————————————————————————————————————–|&lt;br&gt;| 目录           | 说明                                                                                                               |&lt;br&gt;|—————-+——————————————————————————————————————–|&lt;br&gt;| /bin           | 包括了可执行的二进制文件，通常这些二进制文件可以被所有用户访问。FHS规定，该目录至少包括&lt;code&gt;/bin/cat&lt;/code&gt;跟&lt;code&gt;/bin/date&lt;/code&gt;文件 |&lt;br&gt;| /sbin          | 包括了系统的二进制文件，通过需要root权限，用来配置系统                                                             |&lt;br&gt;| /lib           | 包括了&lt;code&gt;/bin&lt;/code&gt;所依赖的库                                                                                             |&lt;br&gt;| /lib/modules   | Linux将从&lt;code&gt;/lib/modules/$kernel-version/&lt;/code&gt;目录下载入内核模块                                                         |&lt;br&gt;| /lib32和/lib64 | 顾名思义，分别存放不同位数的库                                                                                     |&lt;br&gt;| /opt           | 该目录用来存放一些可选的软件，通常情况下，很多第三方的客户软件会选择安装在该目录下                                 |&lt;br&gt;|—————-+——————————————————————————————————————–|&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="study" scheme="http://github.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习（一）命令行</title>
    <link href="http://github.com/2018/04/14/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://github.com/2018/04/14/Linux学习（一）命令行/</id>
    <published>2018-04-14T14:54:30.000Z</published>
    <updated>2018-04-14T14:56:29.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着Linux的发展，现在已经有了非常多的桌面版本，比如著名的Ubuntu。用这些桌面版本系统，可以满足基本的操作，然而对于一些高级点的操作，还是离不开Linux的命令行(Command Line)。而Linux的精髓也更多的体现在命令行上，其强大的功能，海量的工具，可以帮你轻而易举的完成各种复杂的系统管理操作。本文将详细讲述Linux命令行。</p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="帮助类"><a href="#帮助类" class="headerlink" title="帮助类"></a>帮助类</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>Linux有着海量的命令，而每个命令又有很多的不同参数，要记住所有的这些命令是比较困难的，因此，在使用Linux命令行的时候，必须时刻记着查看Linux的帮助，而查看帮助就是采用<code>man</code>命令。<br><a id="more"></a></p><ul><li><p>查看命令帮助</p><p>  以<code>ls</code>命令为例，如果要查看帮助的话可以输入<code>man ls</code>，查看基本的帮助信息也可以直接<code>ls --help</code>。其将以分页的形式显示该命令的完整文档，操作该文档的基本命令有：</p><ul><li>按<code>u</code>上翻页</li><li>按<code>d</code>下翻页</li><li>按空格下翻页</li><li>按回车下移一行</li><li>按<code>/</code>进入搜索模式，输入要搜索的关键字，按回车搜索。</li><li>按<code>n</code>搜索下一个</li><li>按<code>N</code>搜索上一个</li><li>按<code>q</code>退出查看</li></ul></li><li><p>查看配置文件的帮助</p><p>  有些系统的配置文件也同样有对应的帮助文档，可以通过<code>man $configfile</code>来查看，比如<code>/etc/system/sysctl.conf</code>配置文件，查看其帮助可以采用命令<code>man sysctl.conf</code>。</p></li><li><p>查看后台进程(daemon)的帮助</p><p>  Linux在后台运行着很多的程序（称为daemon），如果需要查看某个daemon的帮助，可以用命令<code>man $daemon</code>来查看。如<code>man ntpd</code>将查看时间同步daemon的帮助文档。</p></li><li><p>搜索需要查看的命令</p><p>  Linux命令实在太多，有时候如果不记得准确的命令的名字，可以采用<code>man -k $keyword</code>来搜索，如<code>man -k syslog</code>将列出相关命令：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># man -k syslog</div><div class="line">ipmievd (8)          - IPMI event daemon for sending events to syslog</div><div class="line">logger (1)           - a shell command interface to the syslog(3) system log module</div><div class="line">rsyslog.conf (5)     - rsyslogd(8) configuration file</div><div class="line">rsyslogd (8)         - reliable and extended syslogd</div></pre></td></tr></table></figure></li></ul><h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3><p><code>man</code>命令将展示完整的文档，可以通过<code>whatis</code>来查看命令的简单介绍。</p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>如果需要知道某个命令的完整路径，可以采用<code>whereis $command</code>来查看。</p><h2 id="目录操作类"><a href="#目录操作类" class="headerlink" title="目录操作类"></a>目录操作类</h2><p>|———-+——————————————|<br>| 命令     | 解释                                     |<br>|———-+——————————————|<br>| pwd      | 查看当前目录路径                         |<br>| cd $path | 切换到其它路径                           |<br>| cd ~     | 返回home目录                             |<br>| cd ..    | 返回上一级                               |<br>| cd -     | 返回上一次的目录                         |<br>| ls $path | 查看目录下的内容                         |<br>| ls -a    | 显示目录下所有文件，包括隐藏文件         |<br>| ls -lh   | 列表的形式显示，<code>-h</code>以可读的方式显示大小 |<br>| mkdir    | 创建目录，要递归创建采用<code>mkdir -p</code>       |<br>|———-+——————————————|</p><h2 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>大小写敏感<br>  在Linux系统中，文件名都是大小写敏感的。</p></li><li><p>所有都是文件<br>  Linux基本上将文件，目录，设备等等都视为文件。</p></li></ul><h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><p>查看文件的类型，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># file bugs.tgz</div><div class="line">bugs.tgz: gzip compressed data, from Unix, last modified: Tue Dec 13 01:38:27 2016</div></pre></td></tr></table></figure><p>可以显示文件的类型及修改时间等信息。查看特殊文件如设备文件的时候，还可以带上<code>-s</code>的参数，这样可以识别更多的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># file /dev/sda</div><div class="line">/dev/sda: block special</div><div class="line"># file -s /dev/sda</div><div class="line">/dev/sda: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 1024000 sectors; partition 2: ID=0x8e, starthead 221, startsector 1026048, 208689152 sectors, code offset 0x63</div></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p><code>touch</code>用来创建空文件，或者用来更新文件时间为当前时间。如果加上<code>-t</code>参数，可以为文件设置指定的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># date</div><div class="line">Mon Oct  9 03:19:24 EDT 2017</div><div class="line"># ls -l</div><div class="line">total 4</div><div class="line">-rw-r--r--. 1 root root 6 Jun 19  2016 login.html</div><div class="line"># touch test.txt</div><div class="line"># ls -l</div><div class="line">total 4</div><div class="line">-rw-r--r--. 1 root root 6 Jun 19  2016 login.html</div><div class="line">-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt</div><div class="line"># touch login.html</div><div class="line"># ls -l</div><div class="line">total 4</div><div class="line">-rw-r--r--. 1 root root 6 Oct  9 03:19 login.html</div><div class="line">-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt</div><div class="line"># touch -t 201701011010 login.html</div><div class="line"># ls -l</div><div class="line">total 4</div><div class="line">-rw-r--r--. 1 root root 6 Jan  1  2017 login.html</div><div class="line">-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt</div></pre></td></tr></table></figure><h3 id="删除、复制、移动"><a href="#删除、复制、移动" class="headerlink" title="删除、复制、移动"></a>删除、复制、移动</h3><p>|——–+————————————————————————————–|<br>| 命令   | 解释                                                                                 |<br>|——–+————————————————————————————–|<br>| rm     | 永久删除一个文件，对于此命令，没有所谓的垃圾箱，请慎重                               |<br>| rm -i  | 询问是否真的要删除                                                                   |<br>| rm -rf | 通常<code>rm</code>只是删除文件，如果需要删除目录的时候，必须带上<code>-r</code>参数，<code>-f</code>参数表示强制删除 |<br>| cp     | 拷贝文件                                                                             |<br>| cp -rf | 拷贝目录下所有的文件，并强制覆盖                                                     |<br>| mv     | 移动文件到另一个目录，或者在当前目录下对某个文件改名字                               |<br>|——–+————————————————————————————–|</p><h2 id="文件内容操作类"><a href="#文件内容操作类" class="headerlink" title="文件内容操作类"></a>文件内容操作类</h2><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>查看某个文件的头几行，可以用<code>head</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># head -n 5 /var/log/messages</div><div class="line">Oct  9 03:10:01 traffic-base1 rsyslogd: [origin software=&quot;rsyslogd&quot; swVersion=&quot;7.4.7&quot; x-pid=&quot;697&quot; x-info=&quot;http://www.rsyslog.com&quot;] rsyslogd was HUPed</div><div class="line">Oct  9 03:20:01 traffic-base1 systemd: Started Session 79213 of user root.</div><div class="line">Oct  9 03:20:01 traffic-base1 systemd: Starting Session 79213 of user root.</div><div class="line">Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Unable to fetch my node definition, but the agent run will continue:</div><div class="line">Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Connection refused - connect(2)</div><div class="line"># head -c 5 /var/log/messages</div><div class="line">Oct</div></pre></td></tr></table></figure><p>其中<code>-n</code>参数表示显示多少行，不带此参数，默认显示10行。<code>-c</code>表示显示多少个字符，这里显示了前面5个字符。</p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>与<code>head</code>相反，<code>tail</code>用来显示文件最后几行。同样<code>-n</code>可以用来限制多少行。</p><p><code>tail</code>有个非常重要的用处，<strong><em>就是用来监听某个动态文件的内容，比如实时查看某个日志文件</em></strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># tail -n 5 -F /var/log/messages</div><div class="line">Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:146:in `run&apos;</div><div class="line">Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:92:in `execute&apos;</div><div class="line">Oct  9 03:28:27 traffic-base1 puppet: from /usr/bin/puppet:8:in `&lt;main&gt;&apos;</div><div class="line">Oct  9 03:30:01 traffic-base1 systemd: Started Session 79218 of user root.</div><div class="line">Oct  9 03:30:01 traffic-base1 systemd: Starting Session 79218 of user root.</div><div class="line">Oct  9 03:40:01 traffic-base1 systemd: Started Session 79223 of user root.</div><div class="line">Oct  9 03:40:01 traffic-base1 systemd: Starting Session 79223 of user root.</div></pre></td></tr></table></figure><p>它将不停的侦听文件的改变，并实时的将最后新写入的行打印出来。</p><h3 id="cat-file1-file2-file3-…"><a href="#cat-file1-file2-file3-…" class="headerlink" title="cat $file1 $file2 $file3 …"></a>cat $file1 $file2 $file3 …</h3><p>要显示文件的所有内容，可以用<code>cat</code>命令。<code>cat</code>也可以用来创建新文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat &gt; test.txt</div><div class="line">Today is a good day!</div><div class="line"># cat test.txt</div><div class="line">Today is a good day!</div></pre></td></tr></table></figure><p>这样就可以直接输入文件内容了，输入完成之后按Ctrl+d结束输入。当然，也可以定制结束符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat &gt; test.txt &lt;&lt;stop</div><div class="line">&gt; It&apos;s a good day!</div><div class="line">&gt; stop</div><div class="line"># cat test.txt</div><div class="line">It&apos;s a good day!</div></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p><code>tac</code>名字其实就是<code>cat</code>倒过来写，所以其作用也是一样，就是把文件以倒着的顺序显示出来。</p><h3 id="more跟less"><a href="#more跟less" class="headerlink" title="more跟less"></a>more跟less</h3><p><code>cat</code>会直接把整个文件一次性的显示出来，当文件较大时，显示可能会刷屏，这样不利于查看。如果需要以翻页的形式显示文件的内容，可以采用<code>more</code>或者<code>less</code>命令，其查看方式跟<code>man</code>命令的查看方式类似，可以参考前面的说明。</p><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p><code>strings</code>命令会将文件中的可读字符显示出来，即便改文件是一个二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># strings a.out | tail -n 5</div><div class="line">_edata</div><div class="line">_Znwm@@GLIBCXX_3.4</div><div class="line">_ZN3Out5InnerC1EPS_</div><div class="line">main</div><div class="line">_init</div></pre></td></tr></table></figure><p>其中，<code>a.out</code>是一个二进制文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;随着Linux的发展，现在已经有了非常多的桌面版本，比如著名的Ubuntu。用这些桌面版本系统，可以满足基本的操作，然而对于一些高级点的操作，还是离不开Linux的命令行(Command Line)。而Linux的精髓也更多的体现在命令行上，其强大的功能，海量的工具，可以帮你轻而易举的完成各种复杂的系统管理操作。本文将详细讲述Linux命令行。&lt;/p&gt;
&lt;h1 id=&quot;基础命令&quot;&gt;&lt;a href=&quot;#基础命令&quot; class=&quot;headerlink&quot; title=&quot;基础命令&quot;&gt;&lt;/a&gt;基础命令&lt;/h1&gt;&lt;h2 id=&quot;帮助类&quot;&gt;&lt;a href=&quot;#帮助类&quot; class=&quot;headerlink&quot; title=&quot;帮助类&quot;&gt;&lt;/a&gt;帮助类&lt;/h2&gt;&lt;h3 id=&quot;man&quot;&gt;&lt;a href=&quot;#man&quot; class=&quot;headerlink&quot; title=&quot;man&quot;&gt;&lt;/a&gt;man&lt;/h3&gt;&lt;p&gt;Linux有着海量的命令，而每个命令又有很多的不同参数，要记住所有的这些命令是比较困难的，因此，在使用Linux命令行的时候，必须时刻记着查看Linux的帮助，而查看帮助就是采用&lt;code&gt;man&lt;/code&gt;命令。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://github.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="study" scheme="http://github.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>C++学习(一)</title>
    <link href="http://github.com/2018/04/14/C++%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>http://github.com/2018/04/14/C++学习(一)/</id>
    <published>2018-04-14T14:18:42.000Z</published>
    <updated>2018-04-14T15:30:07.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="extern与static的作用"><a href="#extern与static的作用" class="headerlink" title="extern与static的作用"></a>extern与static的作用</h3><ul><li>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，<code>extern &quot;C&quot;</code>语句实现了类C（类C代表的是跟C语言的编译和链接方式一致的所有语言）和C++的混合编程：在C++源文件中的语句前面加上extern “C”，表明它按照类C的编译和链接规约来编译和链接，而不是C++的编译和链接规约，这样在类C的代码中就可以调用C++的函数或变量等，更多详情参考<a href="http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html</a>。</li><li>static的作用则与extern“水火不相容”，它限制变量或函数只能在本文件中被访问。<a id="more"></a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// test1.cpp</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> c = a;</div><div class="line"></div><div class="line"><span class="comment">// test2.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line"><span class="comment">// int b = 4;</span></div><div class="line"><span class="comment">// error: multiple definition of `b`</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a == "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="comment">// a == 1</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c == "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="comment">// c == 5</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中，</p><ul><li>以<code>extern</code>声明的变量<code>a</code>相当于是两个文件的“全局变量”。</li><li><code>b</code>没有以<code>extern</code>声明，却同时被两个文件都声明了，所以链接时会产生重复定义的错误。</li><li><code>c</code>以<code>static</code>声明，只能在本文件内访问，两个文件各自有一个独立的<code>c</code>，所以不受影响。</li></ul><h3 id="new-operator、operator-new与placement-new"><a href="#new-operator、operator-new与placement-new" class="headerlink" title="new operator、operator new与placement new"></a>new operator、operator new与placement new</h3><ul><li>new operator就是一般所说的<strong>new</strong>，用法如<code>A* pa = new A()</code>，它是C++操作符，是关键字。它的内部操作有三步：调用下面要讲的operator new分配空间，然后调用相关对象的初始化函数，最后返回指针。</li><li>operator new与malloc作用类似，可看成是一个用于分配内存而不构造对象的函数，如<code>A* ptr = (A*)operator new(sizeof(A))</code>。operator new既然可看成一个函数，所以也可以被重载——一般在强调内存分配效率的情况下会考虑重载operator new。</li><li>在上一项中，我用operator new分配了一块内存，然后就遇到了一个问题：怎么在这块内存上面构造对象呢？这就要用到placement new了，它实际上是operator new的一个重载版本，原型是<code>void* operator new (std::size_t size, void* ptr) noexcept;</code>，这里的<code>size</code>参数是被忽略的，只需传入已分配内存的指针<code>ptr</code>参数，目的是在已分配的内存上构造对象，最后将原指针返回。它的用法也与普通函数不同，需在函数后提供构造函数，如，我们可以这样解决上述问题：<code>A* pa = new(ptr) A()</code>。</li></ul><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ul><li>malloc是库函数，new是C++关键字。</li><li>new自行计算空间大小，如<code>int* a = new int[10]</code>；而malloc需要指定空间大小，如<code>int* a = malloc( sizeof(int)*10 )</code>。</li><li>new在动态分配空间时会可调用对象的构造函数初始化对象；而malloc只是分配一段给定大小的内存。</li><li>new分配失败时会抛出异常；而malloc只会返回NULL。</li><li>new可以通过调用malloc来实现，反之则不可以。</li></ul><h3 id="C-多态性"><a href="#C-多态性" class="headerlink" title="C++多态性"></a>C++多态性</h3><p>多态性可以简单理解为“一个接口，多种方法”，程序在运行时才决定调用哪一种方法。C++的多态性是通过虚函数来实现的，虚函数允许子类重新定义父类的方法，即<strong>重写（override）</strong>。它与<strong>重载（overload）</strong>的区别是：重写主要针对名称相同、参数列表相同的函数，运行时才决定函数地址；而重载针对名称相同、参数列表不同的函数，编译期即可决定调用哪个函数，不体现多态性。</p><h3 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h3><p>虚函数是通过<strong>vtable（virtual table，虚函数表）</strong>实现的。<br>注意该表是<strong>针对类的</strong>，而不是针对对象的，也就是说，编译器会为每一个有虚函数的类维护一张vtable，该类的每一个实例都会包含一个表指针，指向同一张表，如下图所示：<br><img src="https://controny.github.io/assets/images/posts/20180312201231.png" alt=""><br>C1和C2的vtable都分别只创建了一张，它们的实例通过表指针访问对应的vtable。<br>当一个子类重写了虚函数，其vtable的相关条目也会被替换为合适的函数地址。比如，假设上述的C2是C1的子类，C2重写了一些虚函数，也增加了一个虚函数，最终两者的vtable就分别是：<br><img src="https://controny.github.io/assets/images/posts/20180312201903.png" alt=""><br><img src="https://controny.github.io/assets/images/posts/20180312201913.png" alt=""></p><p>下面再通过一段测试代码实际感受一下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::h1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    Base* b = <span class="keyword">new</span> Base();</div><div class="line">    Base* d1 = <span class="keyword">new</span> Derived();</div><div class="line">    Derived* d2 = <span class="keyword">new</span> Derived();</div><div class="line">    Derived* d3 = <span class="keyword">new</span> Derived();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以利用GDB的<code>info vtbl [obj]</code>命令来查看对象所指的vtable：<br><img src="https://controny.github.io/assets/images/posts/20180312202024.png" alt=""><br>可以看到：</p><ul><li>作为<code>Base</code>类的对象<code>b</code>所指的vtable包含了它三个虚函数的地址。</li><li><code>d1</code>是<code>Derived</code>类，对应的vtable中，<code>f()</code>是<code>Derived</code>的重写版本，体现了多态性。而因为它由<code>Base</code>指针指向，所以只能访问vtable中的父类函数。</li><li>注意到<code>d1</code>、<code>d2</code>、<code>d3</code>对应的vtable地址是一致的，证明它们都是同一张表。</li></ul><h3 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h3><ul><li>指针是个实体，有自己的内存空间；引用只是一块内存的别名，编译器没有为其分配空间。</li><li>指针可以不初始化，可为空；引用必须初始化，不可为空。</li><li>指针可以改变其指向的对象；引用则不可变。</li><li>实际上，引用可以做的事情指针都可以完成，但引用更加安全。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;extern与static的作用&quot;&gt;&lt;a href=&quot;#extern与static的作用&quot; class=&quot;headerlink&quot; title=&quot;extern与static的作用&quot;&gt;&lt;/a&gt;extern与static的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;语句实现了类C（类C代表的是跟C语言的编译和链接方式一致的所有语言）和C++的混合编程：在C++源文件中的语句前面加上extern “C”，表明它按照类C的编译和链接规约来编译和链接，而不是C++的编译和链接规约，这样在类C的代码中就可以调用C++的函数或变量等，更多详情参考&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;static的作用则与extern“水火不相容”，它限制变量或函数只能在本文件中被访问。
    
    </summary>
    
      <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://github.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vi常用命令</title>
    <link href="http://github.com/2018/04/14/vi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://github.com/2018/04/14/vi常用命令/</id>
    <published>2018-04-14T14:03:27.000Z</published>
    <updated>2018-04-14T14:08:59.603Z</updated>
    
    <content type="html"><![CDATA[<p>vi编辑器拥有众多命令，可以按如下方式分为三类：</p><ul><li>移动光标的命令</li><li>进入输入模式的命令</li><li>进行修改的命令</li></ul><h1 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h1><h2 id="移动一个位置"><a href="#移动一个位置" class="headerlink" title="移动一个位置"></a>移动一个位置</h2><ul><li>j：向下移动一个位置</li><li>k：向上移动一个位置</li><li>h：向左移动一个位置</li><li>l：向右移动一个位置<a id="more"></a></li></ul><h2 id="行内大范围移动"><a href="#行内大范围移动" class="headerlink" title="行内大范围移动"></a>行内大范围移动</h2><ul><li>0：移动至行头</li><li>$：移动至行尾</li><li>^：移动至行内第一个非空格字符上</li></ul><h2 id="单词间移动"><a href="#单词间移动" class="headerlink" title="单词间移动"></a>单词间移动</h2><ul><li>w：移动至下一个单词的词首</li><li>e：移动至下一个单词的词尾</li><li>b：移动至上一个单词的词首</li></ul><h2 id="屏幕内大范围移动"><a href="#屏幕内大范围移动" class="headerlink" title="屏幕内大范围移动"></a>屏幕内大范围移动</h2><ul><li>H：移动至屏幕顶部</li><li>M：移动至屏幕中部</li><li>L：移动至屏幕底部</li></ul><p>可联想high、middle、low这三个词。</p><h2 id="屏幕间移动"><a href="#屏幕间移动" class="headerlink" title="屏幕间移动"></a>屏幕间移动</h2><ul><li>^F：向下移动一个屏幕</li><li>^B：向上移动一个屏幕</li><li>^D：向下移动半个屏幕</li><li>^U：向上移动半个屏幕</li></ul><h2 id="返回前一个位置"><a href="#返回前一个位置" class="headerlink" title="返回前一个位置"></a>返回前一个位置</h2><ul><li>``（两个反引号）：回到前一个位置</li><li>‘’（两个单引号）：回到前一个位置的行头</li></ul><p>具体应用如，使用<strong>G</strong>命令移动到文件末尾后，使用上述命令可以很快速地回到原来的位置。</p><h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><ul><li>i：在当前光标位置前插入</li><li>a：在当前光标位置后插入</li><li>I：在当前行开头插入</li><li>A：在当前行末尾插入</li><li>o：在当前行下一行插入</li><li>O：在当前行上一行插入</li></ul><h1 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h1><h2 id="简单替换"><a href="#简单替换" class="headerlink" title="简单替换"></a>简单替换</h2><ul><li>r：替换一个字符</li><li>R：替换多个字符</li><li>s：以插入方式替换一个字符</li><li>C：以插入方式从当前光标替换到行尾</li><li>S或cc：以插入方式替换整行</li><li>c[<em>move</em>]：以插入方式从当前光标替换到[<em>move</em>]给出的位置（如<code>cw</code>可以向后替换一个单词，因为<code>w</code>使光标移动到下一个单词词首）</li></ul><h2 id="复杂替换"><a href="#复杂替换" class="headerlink" title="复杂替换"></a>复杂替换</h2><ul><li><strong>:s</strong>/<em>pattern</em>/<em>replace</em>/：替换当前行</li><li><strong>:</strong><em>line</em><strong>s</strong>/<em>pattern</em>/<em>replace</em>/：替换指定行</li><li><strong>:</strong><em>line</em>,<em>line</em><strong>s</strong>/<em>pattern</em>/<em>replace</em>/：替换指定范围的行</li><li><strong>:%s</strong>/<em>pattern</em>/<em>replace</em>/：替换所有行</li></ul><p>其中，<em>pattern</em>是替换的正则表达式匹配模式，<em>replace</em>是要替换的文本，<em>line</em>是行号。<br>此外，该命令有几个注意事项：</p><ol><li>为了删除特定项，只需将替换文本留空，如删除<code>root</code>为<strong>：s/root//</strong>。</li><li>以上命令默认只匹配每一行的第一项，在命令末尾加上<strong>g</strong>（global）可匹配所有项。</li><li>在命令末尾加上<strong>c</strong>（confirm）可使vi在改变每一项前发出确认提示。</li><li>可用<strong>.</strong>代表当前行，<strong>$</strong>代表文本最后一行。</li></ol><h2 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h2><ul><li>x：删除当前光标位置的字符</li><li>X：删除当前光标位置前的字符</li><li>D：删除从当前光标位置到行尾的所有字符</li><li>d[<em>move</em>]：删除从当前光标位置到[<em>move</em>]所给位置的字符（用法同c[<em>move</em>]）</li><li>dd：删除当前行</li><li><strong>:</strong><em>line</em><strong>d</strong>：删除指定行</li><li><strong>:</strong><em>line</em>,<em>line</em><strong>d</strong>：删除指定范围的行</li></ul><h2 id="复制文本"><a href="#复制文本" class="headerlink" title="复制文本"></a>复制文本</h2><p>主要有<strong>y</strong>和<strong>yy</strong>两个命令，用法与<strong>d</strong>和<strong>dd</strong>相同。</p><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><ul><li>p：插入到光标后</li><li>P：插入到光标前</li></ul><p>两者不仅可插入复制的文本，也可插入刚被删除的文本，充当剪切-粘贴的用途。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi编辑器拥有众多命令，可以按如下方式分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动光标的命令&lt;/li&gt;
&lt;li&gt;进入输入模式的命令&lt;/li&gt;
&lt;li&gt;进行修改的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;移动光标&quot;&gt;&lt;a href=&quot;#移动光标&quot; class=&quot;headerlink&quot; title=&quot;移动光标&quot;&gt;&lt;/a&gt;移动光标&lt;/h1&gt;&lt;h2 id=&quot;移动一个位置&quot;&gt;&lt;a href=&quot;#移动一个位置&quot; class=&quot;headerlink&quot; title=&quot;移动一个位置&quot;&gt;&lt;/a&gt;移动一个位置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;j：向下移动一个位置&lt;/li&gt;
&lt;li&gt;k：向上移动一个位置&lt;/li&gt;
&lt;li&gt;h：向左移动一个位置&lt;/li&gt;
&lt;li&gt;l：向右移动一个位置
    
    </summary>
    
      <category term="工具" scheme="http://github.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://github.com/tags/Linux/"/>
    
      <category term="vi" scheme="http://github.com/tags/vi/"/>
    
  </entry>
  
  <entry>
    <title>Segmentation Fault分析</title>
    <link href="http://github.com/2018/04/14/Segmentation%20Fault%E5%88%86%E6%9E%90/"/>
    <id>http://github.com/2018/04/14/Segmentation Fault分析/</id>
    <published>2018-04-14T13:57:07.000Z</published>
    <updated>2018-04-14T14:00:14.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Segmentation-Fault"><a href="#什么是Segmentation-Fault" class="headerlink" title="什么是Segmentation Fault"></a>什么是Segmentation Fault</h1><p><a href="https://en.wikipedia.org/wiki/Segmentation_fault" target="_blank" rel="external">维基百科</a>对此有简单明了的定义：</p><blockquote><p>In computing, a <strong>segmentation fault</strong> (often shortened to segfault) or access violation is a fault, or failure condition, raised by hardware with memory protection, notifying an operating system (OS) the software has attempted to access a restricted area of memory (a memory access violation).</p></blockquote><p>简单地用中文说，就是访问了不属于该进程的内存。而我总是对一个名词的来源感兴趣，为什么这一现象要称为Segmentation Fault呢？<br>起初，我一直以为是与早期操作系统的分段式内存管理机制有关（memory segmentation ），在网上查了一下才发现两者并无直接联系：</p><blockquote><p>“Segmentation” isn’t at all related to the old “segmented memory model” used by early x86 processors; it’s an earlier use which just refers to a portion or <em>segment</em> of memory.</p></blockquote><p>原来segmentation仅仅是指一段（segment）内存o(╯□╰)o<br><a id="more"></a></p><h1 id="什么情况会产生Segmentation-Fault"><a href="#什么情况会产生Segmentation-Fault" class="headerlink" title="什么情况会产生Segmentation Fault"></a>什么情况会产生Segmentation Fault</h1><p>在写C语言的时候，最容易产生Segmentation Fault的大概有两种情况：</p><ul><li>访问空指针指向的内存</li><li>越界访问数组</li></ul><p>第一种情况最简单的示例就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    int *p = NULL;</div><div class="line">    *p = 1;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里，空指针<code>p</code>被设为NULL，指向的内存便不属于该进程，对<code>p</code>指向的内存赋值自然就属于非法访问内存了。<br>第二种情况大概是每个学过C语言的人都会遇到的。然而，越界访问并不会必然导致Segmentation Fault，因为有时候你会“幸运”地访问到同属于该进程的一块内存。当然，这种“幸运”其实是一种巨大的不幸，出现这种情况时，运行时环境不会直接了当地告诉你有错误，而是会以莫名其妙地方式暗示你。</p><h1 id="如何调试Segmentation-Fault"><a href="#如何调试Segmentation-Fault" class="headerlink" title="如何调试Segmentation Fault"></a>如何调试Segmentation Fault</h1><p>Segmentation Fault令人头疼的地方就是，运行时环境并不会直接告诉你代码的哪一行出现了问题。过去，我的做法一直是凭猜测，然后在可能的地方输出特定信息以观察程序是否在该位置出错。直到我意识到可以用强大的调试工具GDB来提高效率。<br>如第一种情况的示例，在编译的时候加入<code>-g</code>参数可令其生成调试信息以便待会用GDB调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -g c_test.c</div></pre></td></tr></table></figure></p><p>然后就是用GDB执行生成可执行文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gdb ./a.out</div></pre></td></tr></table></figure></p><p>进入交互界面后输入<code>r</code>让程序开跑，之后就能看到非常醒目的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line">0x00000000004004ed in main (argc=1, argv=0x7fffffffdd38) at c_test.c:7</div><div class="line">7    *p = 1;</div></pre></td></tr></table></figure></p><p>于是便瞬间锁定了错误所在的位置，又可以愉快改下一个bug了～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Segmentation-Fault&quot;&gt;&lt;a href=&quot;#什么是Segmentation-Fault&quot; class=&quot;headerlink&quot; title=&quot;什么是Segmentation Fault&quot;&gt;&lt;/a&gt;什么是Segmentation Fault&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Segmentation_fault&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;对此有简单明了的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, a &lt;strong&gt;segmentation fault&lt;/strong&gt; (often shortened to segfault) or access violation is a fault, or failure condition, raised by hardware with memory protection, notifying an operating system (OS) the software has attempted to access a restricted area of memory (a memory access violation).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地用中文说，就是访问了不属于该进程的内存。而我总是对一个名词的来源感兴趣，为什么这一现象要称为Segmentation Fault呢？&lt;br&gt;起初，我一直以为是与早期操作系统的分段式内存管理机制有关（memory segmentation ），在网上查了一下才发现两者并无直接联系：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Segmentation” isn’t at all related to the old “segmented memory model” used by early x86 processors; it’s an earlier use which just refers to a portion or &lt;em&gt;segment&lt;/em&gt; of memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来segmentation仅仅是指一段（segment）内存o(╯□╰)o&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://github.com/categories/C/"/>
    
    
      <category term="C" scheme="http://github.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>slim环境下设置gpu_option</title>
    <link href="http://github.com/2018/04/14/slim%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%AE%BE%E7%BD%AEgpu-option/"/>
    <id>http://github.com/2018/04/14/slim环境下设置gpu-option/</id>
    <published>2018-04-14T13:45:42.000Z</published>
    <updated>2018-04-14T13:48:26.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置gpu-option"><a href="#设置gpu-option" class="headerlink" title="设置gpu_option"></a>设置<code>gpu_option</code></h2><p>使用Tensorflow的GPU版本进行深度学习训练时，Tensorflow默认占用对进程可见的所有GPU内存以提高训练效率。然而，在有些情况下，比如在多人共享的机器上训练时，系统管理员要求不能霸占所有GPU资源，否则其他人就无法使用了（博主就是这种情况），这时候我们就想要限制程序对GPU的使用，用英文讲，就是Allow GPU memory growth。根据<a href="https://www.tensorflow.org/tutorials/using_gpu#allowing_gpu_memory_growth" target="_blank" rel="external">官网的说明</a>，我们可以通过配置Session的<code>gpu_option</code>来达到上述目的。具体地，有两种参数可设置：</p><a id="more"></a><ol><li><code>allow_growth</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">config = tf.ConfigProto()</div><div class="line">config.gpu_options.allow_growth = True</div><div class="line">session = tf.Session(config=config, ...)</div></pre></td></tr></table></figure></li></ol><p>上述代码的作用，简单地讲，就是按需分配：进程一开始运行的时候，仅为其分配少量的GPU内存，而随着进程的继续运行，对计算资源的需求加大时再分配更多的GPU内存。</p><ol><li><code>per_process_gpu_memory_fraction</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">config = tf.ConfigProto()</div><div class="line">config.gpu_options.per_process_gpu_memory_fraction = 0.4</div><div class="line">session = tf.Session(config=config, ...)</div></pre></td></tr></table></figure></li></ol><p>顾名思义，这是在设置进程使用每个GPU的内存上限，例如，在上述代码里，该进程最多只会占用每个GPU内存的40%。</p><h2 id="在slim环境下设置gpu-option"><a href="#在slim环境下设置gpu-option" class="headerlink" title="在slim环境下设置gpu_option"></a>在slim环境下设置<code>gpu_option</code></h2><p><a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim">slim</a>是Tensorflow于2016推出的模块，是一种high-level库，讲许多深度学习算法封装起来，极大地简化了Tensorflow的代码。对于一般的神经网络训练，slim封装了<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/slim/python/slim/learning.py#L531"><code>slim.learning.train</code></a>方法，程序员连Session都不需要自己创建了，然而，按照上述方法，<code>gpu_option</code>需要在创建Session时设置，这就产生了问题。所幸的是，<code>slim.learning.train</code>提供的参数已经考虑到了这个问题：</p><blockquote><p>session_config: An instance of <code>tf.ConfigProto</code> that will be used to<br>      configure the <code>Session</code>. If left as <code>None</code>, the default will be used.</p></blockquote><p> 所以，我们的设置方法就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">session_config = tf.ConfigProto()</div><div class="line">session_config.gpu_options.allow_growth = True</div><div class="line">slim.learning.train(..., session_config=session_config)</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">session_config = tf.ConfigProto()</div><div class="line">session_config.per_process_gpu_memory_fraction = 0.4</div><div class="line">slim.learning.train(..., session_config=session_config)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      slim
    
    </summary>
    
      <category term="深度学习" scheme="http://github.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Tensorflow" scheme="http://github.com/tags/Tensorflow/"/>
    
      <category term="slim" scheme="http://github.com/tags/slim/"/>
    
      <category term="深度学习" scheme="http://github.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Pages 搭建个人博客</title>
    <link href="http://github.com/2018/04/13/Hexo%20+%20GitHub%20Pages%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://github.com/2018/04/13/Hexo + GitHub Pages 搭建个人博客/</id>
    <published>2018-04-13T14:08:49.000Z</published>
    <updated>2018-04-13T14:09:53.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.</p><footer><strong>Documentation</strong><cite><a href="https://hexo.io/docs/index.html" target="_blank" rel="external">hexo.io</a></cite></footer></blockquote><p>这一篇 note 讲解如何使用 <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> + <a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> 搭建个人博客，并用 GitHub 进行版本控制。其中源文件位于 hexo 分支，静态文件位于 master 分支。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>安装最新版的 <a href="https://git-scm.com/" target="_blank" rel="external">Git</a>。在命令行输入 <code>git version</code> 检查 git 是否安装成功。</p></li><li><p>安装 LTS 版的 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>。同样在命令行输入 <code>node -v</code> 和 <code>npm -v</code>以检查 node.js 是否安装成功。</p></li><li><p>注册 GitHub 账号，新建一个 repository，一般命名为 <code>username.github.io</code>，这样 GitHub 会自动开启 GitHub Pages 功能。勾选 <code>Initialize this repository with a README</code> 的话即可访问个人主页，否则需要添加内容才能访问，建议暂时不要勾选。</p></li><li><p>GitHub 添加 SSH（推荐），可参考 <a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="external">Connecting to GitHub with SSH</a>。</p></li></ul><a id="more"></a><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure><p>使用 <code>hexo version</code> 检查是否安装成功。</p><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>选择一个目录，比如 D:\github，键入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init username.github.io</div><div class="line">cd username.github.io</div><div class="line">npm install</div></pre></td></tr></table></figure><p>这样就创建了一个名为 <code>username.github.io</code> 的 Hexo 工程（文件夹）。注意，<code>hexo init &lt;folder&gt;</code> 命令要求 folder 为空文件夹，否则会报错。</p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server  (简写为 hexo s)</div></pre></td></tr></table></figure><p>默认情况下，访问网址为 <code>http://localhost:4000/</code>。打开网址，可以看到一篇 landscape 主题的 Hello World 博客。一般修改 Markdown 文件，不需要重启服务器，直接刷新浏览器即可，除非你修改配置文件。</p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><p>工程根目录下的 <strong>_config.yml</strong> 称为站点配置文件，可以配置一些个人信息等，具体可参考<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">Configuration</a>。</p><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>每个主题的目录下也会有一个 <strong>_config.yml</strong> 文件，称为主题配置文件。Hexo 有丰富多彩的主题，这里以 <a href="https://github.com/iTimeTraveler/hexo-theme-hiker">hexo-theme-hiker</a> 为例，说明如何更换主题。</p><p>安装主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd username.github.io</div><div class="line">git clone git@github.com:iTimeTraveler/hexo-theme-hiker.git themes/hiker</div></pre></td></tr></table></figure><p>PS：这样安装主题并不能 push 到 GitHub 中去，可使用 <code>fork + subtree</code> 的方法解决，具体参考 <a href="http://w4lle.com/2016/06/06/Hexo-themes/" target="_blank" rel="external">Hexo 主题同步</a>。感谢 <a href="https://github.com/tyrionyu">@Tyrion Yu</a> 的帮助。</p><p>修改站点配置文件，将 theme 修改为 hiker：</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hiker</code></pre><p>重启服务器，即可查看效果。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要 clean 一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo server</div></pre></td></tr></table></figure><p>PS：如果不需要 landscape 主题，直接删除 themes 下的对应文件夹即可。</p><h4 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h4><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>然后修改站点配置文件：</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:username/username.github.io.git  # 这种配置需使用 SSH  branch: master  message: message  # 默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}</code></pre><p>其中 branch 为静态文件所在的分支，<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="external">必须为 master 分支</a>。message 表示自定义提交信息，一般不需要配置，删除该行即可。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h4><p>为工程创建 Git 仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd username.github.io</div><div class="line">git init</div></pre></td></tr></table></figure><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>此时 Git 仓库为空，不能直接运行 <code>git branch hexo</code> 来创建新的分支，可通过以下命令创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b hexo</div></pre></td></tr></table></figure><h4 id="push-源文件"><a href="#push-源文件" class="headerlink" title="push 源文件"></a>push 源文件</h4><p>添加所有文件，提交到本地仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure><p>添加远程仓库，并push：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:username.github.io.git</div><div class="line">git push -u origin hexo</div></pre></td></tr></table></figure><h4 id="部署静态文件"><a href="#部署静态文件" class="headerlink" title="部署静态文件"></a>部署静态文件</h4><p>先生成静态文件，再部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate  （简写为 hexo g）</div><div class="line">hexo delpoy  (简写为 hexo d)</div></pre></td></tr></table></figure><p>此时整个部署过程就结束啦，你可以通过 <code>https://username.github.io/</code> 访问自己的 Github Pages。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><p><a href="https://gist.github.com/btfak/18938572f5df000ebe06fbd1872e4e39" target="_blank" rel="external">How to use Hexo and deploy to GitHub Pages</a></p></li><li><p><a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo Documentation</a></p></li><li><p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">知乎：使用hexo，如果换了电脑怎么更新博客？</a></p></li><li><p><a href="https://github.com/iTimeTraveler/hexo-theme-hiker">An attractive theme for Hexo. called “Hiker”, short for “HikerNews”</a></p></li><li><p><a href="http://w4lle.com/2016/06/06/Hexo-themes/" target="_blank" rel="external">Hexo 主题同步</a></p></li><li><p><a href="https://aoxuis.me/bo-ke/2013-08-06-git-subtree" target="_blank" rel="external">使用 git subtree 集成项目到子目录</a></p></li><li><p><a href="https://www.atlassian.com/blog/git/alternatives-to-git-submodule-git-subtree" target="_blank" rel="external">Git subtree: the alternative to Git submodule</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://hexo.io/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo.io&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;这一篇 note 讲解如何使用 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; + &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github Pages&lt;/a&gt; 搭建个人博客，并用 GitHub 进行版本控制。其中源文件位于 hexo 分支，静态文件位于 master 分支。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装最新版的 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git&lt;/a&gt;。在命令行输入 &lt;code&gt;git version&lt;/code&gt; 检查 git 是否安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 LTS 版的 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;。同样在命令行输入 &lt;code&gt;node -v&lt;/code&gt; 和 &lt;code&gt;npm -v&lt;/code&gt;以检查 node.js 是否安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注册 GitHub 账号，新建一个 repository，一般命名为 &lt;code&gt;username.github.io&lt;/code&gt;，这样 GitHub 会自动开启 GitHub Pages 功能。勾选 &lt;code&gt;Initialize this repository with a README&lt;/code&gt; 的话即可访问个人主页，否则需要添加内容才能访问，建议暂时不要勾选。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GitHub 添加 SSH（推荐），可参考 &lt;a href=&quot;https://help.github.com/articles/connecting-to-github-with-ssh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Connecting to GitHub with SSH&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="blog" scheme="http://github.com/categories/blog/"/>
    
    
      <category term="Git笔记" scheme="http://github.com/tags/Git%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git--命令(二)</title>
    <link href="http://github.com/2018/04/13/Git--%E5%91%BD%E4%BB%A4(%E4%BA%8C)/"/>
    <id>http://github.com/2018/04/13/Git--命令(二)/</id>
    <published>2018-04-13T14:04:29.000Z</published>
    <updated>2018-04-13T14:06:01.044Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><footer><strong>Documentation</strong><cite><a href="https://git-scm.com/" target="_blank" rel="external">git-scm.com</a></cite></footer></blockquote><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。它是由 Linux 之父 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。本文介绍了 Git 的常用命令。</p><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><p>在学习 Git 命令之前，首先要理解它的三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存在本地数据库中；已修改表示修改了文件，但还没保存到数据库中，增加、删除文件也相当于已修改；已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="Working tree, staging area, and Git directory"></p><a id="more"></a><p>它们之间的关系可以参考 <a href="http://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="external">Git 工作区、暂存区和版本库</a>。</p><p>在阅读下面的内容之前，最好在自己的电脑上<a href="https://git-scm.com/" target="_blank" rel="external">安装 Git</a>，然后按照顺序操作。如果你想先感受一下 Git 的魅力， <a href="https://try.github.io/" target="_blank" rel="external">Try Git</a> 是一个不错的选择。</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>安装完 Git，初次运行前需要做一些配置，比如用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"Your Name"</span></div><div class="line">git config --global user.email email@example.com</div></pre></td></tr></table></figure><p>Windows 环境下，推荐使用文本编辑器 <a href="https://notepad-plus-plus.org/" target="_blank" rel="external">Notepad++</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 注意更改为自己的安装目录</span></div><div class="line">git config --global core.editor <span class="string">"'C:\Program Files\Notepad++\notepad++.exe' -multiInst -nosession"</span></div></pre></td></tr></table></figure><p>配置完成后，可以通过 <code>git config --list</code> 查看所有的配置信息，或者使用 <code>git config user.name</code> 查看单个信息。</p><p>另外，还可以自定义配置一些命令的别名，方便记忆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.last <span class="string">'log -1'</span></div></pre></td></tr></table></figure><p>这样 <code>git last</code> 就相当于 <code>git log -1</code>，用于查看最后一次的提交记录。我比较喜欢这样配置，用于查看提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.lg <span class="string">"log --oneline --decorate --graph --all"</span></div></pre></td></tr></table></figure><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>创建版本库有两种方式，一种是使用 <code>git clone</code> 从现有 Git 仓库中拷贝项目，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</div></pre></td></tr></table></figure><p>另一种是通过 <code>git init</code> 初始化一个 Git 仓库，省略 directory 会在当前文件夹中创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init &lt;directory&gt;</div></pre></td></tr></table></figure><p>例如，在 <code>D:\test</code> 文件夹下执行 <code>git init</code> 命令，这样会生成一个 <strong>隐藏</strong> 的 .git 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> D:/<span class="built_in">test</span>/.git/</div></pre></td></tr></table></figure><h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p>基本的 Git 工作流程如下：</p><ol><li><p>在工作目录中修改文件。</p></li><li><p>暂存文件，将文件的快照放入暂存区域。</p></li><li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p></li></ol><p>使用 Git 时文件的生命周期如下：</p><p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="The lifecycle of the status of your files"></p><p>上图来源于 <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository" target="_blank" rel="external">Pro Git</a>，这里的 <code>Add the file</code> 应该理解为使用 <code>git add</code> 命令，<code>Reomve the file</code> 则是手动删除文件。</p><h3 id="First-Commit"><a href="#First-Commit" class="headerlink" title="First Commit"></a>First Commit</h3><p>在 <code>D:\test</code> 中手动添加 <code>a.txt</code> 文件，使用 Notepad++ 编辑（<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="external">不要用记事本</a>），然后运行 <code>git status</code> 命令，查看当前状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">No commits yet</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        a.txt</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</div></pre></td></tr></table></figure><p>Git 的提示十分人性化，可以看出 <code>a.txt</code> 处于 <code>Untracked</code> 状态。执行 <code>git add</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git add a.txt</div><div class="line"></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">No commits yet</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   a.txt</div></pre></td></tr></table></figure><p>此时 <code>a.txt</code> 处于 <code>Staged</code> 状态，可以通过 <code>git rm --cached &lt;file&gt;...</code> 使其回到 <code>Untracked</code> 状态。最后执行 <code>git commit</code> 命令，进行第一次提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"Add a.txt"</span></div><div class="line">[master (root-commit) 3fbc25c] Add a.txt</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 a.txt</div></pre></td></tr></table></figure><p>其中 <code>-m</code> 是参数，后面跟着提交信息。如果配置了文本编辑器，执行不带参数的 <code>git commit</code> 后，可在弹出的编辑器中填写提交信息。注意只有 <strong>保存文件</strong> 并 <strong>退出编辑器</strong>，commit 才会生效。</p><p>另外，在只 <strong>修改文件</strong> 时，使用 <code>-a</code> 可以跳过 <code>Staged</code> 状态直接提交，可以和 <code>-m</code> 一起使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -am <span class="string">"Update file"</span></div></pre></td></tr></table></figure><h3 id="Second-Commit"><a href="#Second-Commit" class="headerlink" title="Second Commit"></a>Second Commit</h3><p>添加 <code>b.txt</code>，然后修改 <code>a.txt</code>，查看此时的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   a.txt</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        b.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure><p>此时 <code>a.txt</code> 处于 <code>Modified</code> 状态，可通过 <code>git checkout -- &lt;file&gt;...</code> 放弃更改，但是要 <strong>慎用</strong>，这些更改是找不回来的。 而 <code>b.txt</code> 处于 <code>Untracked</code> 状态。</p><p><code>git diff</code> 命令用于比较工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><p><code>git diff --cached</code>（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些）可以查看已暂存的将要添加到下次提交里的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 69dd9b9..b0c1f18 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1 +1,2 @@</div><div class="line"> aaaaaaaaaa    # a.txt 原本的内容</div><div class="line">+AAAAAAAAAA    # a.txt 添加的内容</div><div class="line">$ git diff --staged # nothing</div></pre></td></tr></table></figure><p>添加这两个文件到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git add <span class="string">"*.txt"</span> <span class="comment"># git add .(一个点，表示添加所有文件)</span></div><div class="line"></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   a.txt</div><div class="line">        new file:   b.txt</div></pre></td></tr></table></figure><p>同理，<code>git reset HEAD &lt;file&gt;...</code> 命令可使文件回到 add 之前的状态。此时再次执行 diff：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ git diff <span class="comment"># nothing</span></div><div class="line"></div><div class="line">$ git diff --staged</div><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 69dd9b9..b0c1f18 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1 +1,2 @@</div><div class="line"> aaaaaaaaaa</div><div class="line">+AAAAAAAAAA</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">new file mode 100644</div><div class="line">index 0000000..817e5ca</div><div class="line">--- /dev/null</div><div class="line">+++ b/b.txt</div><div class="line">@@ -0,0 +1 @@</div><div class="line">+bbbbbbbbbb <span class="comment"># b.txt 中添加的内容</span></div></pre></td></tr></table></figure><p>以上对比可以看出不同 diff 的差别。执行 commit 命令进行第二次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"Update a.txt and add b.txt"</span></div><div class="line">[master 24e0903] Update a.txt and add b.txt</div><div class="line"> 2 files changed, 2 insertions(+)</div><div class="line"> create mode 100644 b.txt</div></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>为了演示删除操作，先添加 <code>c.txt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git add c.txt</div><div class="line"></div><div class="line">$ git commit -m <span class="string">"Add c.txt"</span></div><div class="line">[master 9d8751a] Add c.txt</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 c.txt</div></pre></td></tr></table></figure><p>手动删除后的状态为 <code>Untracked</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        deleted:    c.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure><p>使用 <code>git checkout -- &lt;file&gt;...</code> 撤销，然后执行 <code>git rm</code> 命令，此时的状态为 <code>Staged</code>。这就是两者的差别吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git rm c.txt</div><div class="line">rm <span class="string">'c.txt'</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        deleted:    c.txt</div></pre></td></tr></table></figure><p>提交删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"Delete c.txt"</span></div><div class="line">[master 95d6e7e] Delete c.txt</div><div class="line"> 1 file changed, 1 deletion(-)</div><div class="line"> delete mode 100644 c.txt</div></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除 <code>git rm -f &lt;file&gt;</code>。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>而 <code>git rm --cached</code> 命令只会将文件从 Git 仓库中删除，但仍然保留在当前工作目录中。当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆无关的文件添加到暂存区时，这一做法尤其有用。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在 Git 中，用 HEAD 表示当前版本，上一个版本就是 <code>HEAD^</code>（<code>HEAD~</code>）。有关 <code>~</code> 和 <code>^</code> 的区别，请参考 <a href="https://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git" target="_blank" rel="external">What’s the difference between HEAD^ and HEAD~ in Git?</a></p><p>注意，Windows 环境下 <code>^</code> 识别不了，必须加 <strong>双引号</strong> 才行，像这样 <code>&quot;HEAD^&quot;</code>。</p><p>假如又要用到 <code>c.txt</code>，想反悔，怎么办？Git 允许我们在版本的历史之间穿梭，使用 <code>git reset --hard &lt;commit_id&gt;</code> 命令。如果不知道 commit_id，<code>git log</code> 可以查看提交历史。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git lg <span class="comment"># 自定义的 git log</span></div><div class="line">* 95d6e7e (HEAD -&gt; master) Delete c.txt</div><div class="line">* 9d8751a Add c.txt</div><div class="line">* 24e0903 Update a.txt and add b.txt</div><div class="line">* 3fbc25c Add a.txt</div><div class="line"></div><div class="line">$ git reset --hard HEAD~</div><div class="line">HEAD is now at 9d8751a Add c.txt</div><div class="line"></div><div class="line">$ git lg</div><div class="line">* 9d8751a (HEAD -&gt; master) Add c.txt</div><div class="line">* 24e0903 Update a.txt and add b.txt</div><div class="line">* 3fbc25c Add a.txt</div></pre></td></tr></table></figure><p>其中 <code>3fbc25c</code> 为版本号（commit_id），它是一个由 SHA-1 计算出来的校验和，用十六进制表示，而且每次都不一样。因为我使用了自定义的 <code>git lg</code>， 这里只显示 7 位，其实它是 <code>3fbc25c7d58e06169a45b587a9c6164234efd43c</code>。</p><p><code>git log</code> 功能十分强大，可参考 <a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="external">Git Basics - Viewing the Commit History</a>。</p><p>另外，可以使用命令 <code>git reflog</code> 查看命令历史。如果想回到 <code>Delete c.txt</code> 的版本，直接 reset 对应的 commit_id 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div><div class="line">9d8751a (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~</div><div class="line">95d6e7e HEAD@&#123;1&#125;: commit: Delete c.txt</div><div class="line">9d8751a HEAD@&#123;2&#125;: commit: Add c.txt</div><div class="line">24e0903 HEAD@&#123;3&#125;: commit: Update a.txt and add b.txt</div><div class="line">3fbc25c HEAD@&#123;4&#125;: commit (initial): Add a.txt</div></pre></td></tr></table></figure><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>其实 reset 分三类，分别为 <code>--soft</code>、<code>--mixed</code>（默认，可不加）和 <code>--hard</code>，它们之间到底有什么区别呢？我们做个试验。注意此时是 <code>Add c.txt</code> 的版本。</p><h4 id="soft"><a href="#soft" class="headerlink" title="soft"></a>soft</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git reset --soft HEAD~</div><div class="line"></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   c.txt</div></pre></td></tr></table></figure><p><code>--soft</code> 参数使文件回到了 <code>Staged</code> 的状态。</p><h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><p>重新回到 <code>Add c.txt</code> 的版本，执行 <code>--mixed</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git reset --mixed HEAD~</div><div class="line"></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        c.txt</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</div></pre></td></tr></table></figure><p><code>--mixed</code> 参数使文件回到了 <code>Untracked</code> 状态。</p><h4 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h4><p>重新回到 <code>Add c.txt</code> 的版本，执行 <code>--hard</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD~</div><div class="line">HEAD is now at 24e0903 Update a.txt and add b.txt</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure><p>而 <code>--hard</code> 参数直接回到了上一个版本。</p><p>想要了解更多关于 Reset 的知识，请参考 <a href="https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified" target="_blank" rel="external">Git Tools - Reset Demystified</a>。</p><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<br>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。为何 Git 的分支模型如此出众呢？Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p><p>下面演示了 Git 分支的工作流程。创建并切换到 dev 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line"></div><div class="line">$ git checkout dev</div><div class="line">Switched to branch <span class="string">'dev'</span></div></pre></td></tr></table></figure><p>简单地，这两个命令可以合并为一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch <span class="string">'dev'</span></div></pre></td></tr></table></figure><p>在 dev 分支添加 <code>d.txt</code>，修改 <code>c.txt</code>，提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line"></div><div class="line">$ git commit -m <span class="string">"Add d.txt and update c.txt"</span></div><div class="line">[dev 7f5d2b1] Add d.txt and update c.txt</div><div class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</div><div class="line"> create mode 100644 d.txt</div></pre></td></tr></table></figure><p>切换到 master 分支，合并 dev 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line"></div><div class="line">$ git merge dev</div><div class="line">Updating 9d8751a..7f5d2b1</div><div class="line">Fast-forward</div><div class="line"> c.txt | 2 +-</div><div class="line"> d.txt | 1 +</div><div class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</div><div class="line"> create mode 100644 d.txt</div></pre></td></tr></table></figure><p>最后删除 dev 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d dev</div><div class="line">Deleted branch dev (was 7f5d2b1).</div></pre></td></tr></table></figure><h2 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h2><p>为了能在任意 Git 项目上协作，需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。</p><p>这里以 GitHub 为例，演示如何使用远程仓库。在 GitHub 上创建一个新的 Repository，不要添加任何内容，完成后如下图所示：</p><p><img src="github.png" alt="GitHub"></p><p>添加远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:muwednesday/git-learning.git</div></pre></td></tr></table></figure><p>使用命令 <code>git push</code> 将本地仓库推送到 GitHub，其中 <code>-u</code> 为设置当前本地分支的默认远程分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div><div class="line">Counting objects: 14, <span class="keyword">done</span>.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (7/7), <span class="keyword">done</span>.</div><div class="line">Writing objects: 100% (14/14), 913 bytes | 304.00 KiB/s, <span class="keyword">done</span>.</div><div class="line">Total 14 (delta 2), reused 0 (delta 0)</div><div class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</div><div class="line">To github.com:muwednesday/git-learning.git</div><div class="line"> * [new branch]      master -&gt; master</div><div class="line">Branch <span class="string">'master'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</div></pre></td></tr></table></figure><p>刷新页面后即可看到文件。然后在 GitHub 上创建一个 <code>README.md</code> 的文件，提交。</p><p>返回本地仓库，查看状态，这里居然显示 <code>up to date</code>。本来应该落后才对，为什么呢？原因参见 <a href="https://stackoverflow.com/questions/27828404/why-does-git-status-show-branch-is-up-to-date-when-changes-exist-upstream" target="_blank" rel="external">Why does git status show branch is up-to-date when changes exist upstream?</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</div><div class="line"></div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure><p>最后使用命令 <code>git pull</code> 来自动的抓取然后合并远程分支到当前分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git pull</div><div class="line">remote: Counting objects: 3, done.</div><div class="line">remote: Compressing objects: 100% (2/2), done.</div><div class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</div><div class="line">Unpacking objects: 100% (3/3), done.</div><div class="line">From github.com:muwednesday/git-learning</div><div class="line">   7f5d2b1..ad27849  master     -&gt; origin/master</div><div class="line">Updating 7f5d2b1..ad27849</div><div class="line">Fast-forward</div><div class="line"> README.md | 1 +</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 README.md</div></pre></td></tr></table></figure><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git</a></p></li><li><p><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="external">GitHub Cheat Sheet</a></p></li><li><p><a href="https://git-scm.com/doc" target="_blank" rel="external">Reference Manual</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a></p></li><li><p><a href="https://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git" target="_blank" rel="external">What’s the difference between HEAD^ and HEAD~ in Git?</a></p></li><li><p><a href="https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting" target="_blank" rel="external">Reset, Checkout, and Revert</a></p></li><li><p><a href="https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch" target="_blank" rel="external">What is the difference between ‘git pull’ and ‘git fetch’?</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git-scm.com&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。它是由 Linux 之父 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。本文介绍了 Git 的常用命令。&lt;/p&gt;
&lt;h2 id=&quot;三种状态&quot;&gt;&lt;a href=&quot;#三种状态&quot; class=&quot;headerlink&quot; title=&quot;三种状态&quot;&gt;&lt;/a&gt;三种状态&lt;/h2&gt;&lt;p&gt;在学习 Git 命令之前，首先要理解它的三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存在本地数据库中；已修改表示修改了文件，但还没保存到数据库中，增加、删除文件也相当于已修改；已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。&lt;/p&gt;
&lt;p&gt;由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/areas.png&quot; alt=&quot;Working tree, staging area, and Git directory&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://github.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://github.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hiker博客主题配置</title>
    <link href="http://github.com/2018/04/13/hiker%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://github.com/2018/04/13/hiker博客主题配置/</id>
    <published>2018-04-13T02:01:03.000Z</published>
    <updated>2018-04-13T04:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hiker"><a href="#Hiker" class="headerlink" title="Hiker"></a>Hiker</h1><p>An attractive, exquisite theme for <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>. named “Hiker”, short for “HikerNews”.  </p><p><a href="https://itimetraveler.github.io/hexo-theme-hiker/" target="_blank" rel="external"><strong>☞ 在线预览</strong></a>  |  <a href="https://gitter.im/hexo-theme-hiker/Lobby?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link" target="_blank" rel="external"><strong>Hiker问题交流群</strong></a><br><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png" alt="Desktop Preview"><br><a id="more"></a><br><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/article-chrome.png" alt="Post Preview"><br><img src="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/preview-mobile.png?raw=true" alt="Mobile Preview"></p><!--more--><p>以上Demo站点的源文件在这里，大家有需要的可以参考：<a href="https://github.com/iTimeTraveler/hexo-theme-hiero/tree/site-source">https://github.com/iTimeTraveler/hexo-theme-hiero/tree/site-source</a></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>从GitHub上获取代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker</span></div></pre></td></tr></table></figure><ol><li><p>启用</p><p>把Hexo主目录下的 <code>_config.yml</code> 文件中的字段 <code>theme</code> 修改为 <code>hiker</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line">theme: hiker</div></pre></td></tr></table></figure></li><li><p>更新</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> themes/Hiker</span></div><div class="line"><span class="meta">$</span><span class="bash"> git pull</span></div></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="自定义首页背景"><a href="#自定义首页背景" class="headerlink" title="自定义首页背景"></a>自定义首页背景</h3><p>您可以将选择的大图放到 <code>YOUR_HEXO_SITE\themes\hiker\source\css\images</code> 文件夹下. 然后更改 hiker/_config.yml文件里的<code>home_background_image</code>字段.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Homepage</span></div><div class="line"><span class="comment"># eg. home_background_image: [css/images/home-bg.jpg, http://t.cn/RMbvEza]</span></div><div class="line"><span class="comment"># eg. mode: image | polyline | trianglify</span></div><div class="line"><span class="attr">home_background_image:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  mode:</span> <span class="string">image</span></div><div class="line"><span class="attr">  rolling:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  url:</span> <span class="string">[css/images/home-bg.jpg,</span> <span class="string">css/images/sample.jpg,</span> <span class="attr">https://source.unsplash.com/collection/954550/1920x1080]</span></div></pre></td></tr></table></figure><p>首页背景填充方式有三种可选mode：</p><ul><li><code>image</code>: 大图模式</li><li><code>trianglify</code>: 多边形渐变背景</li><li><code>polyline</code>: 随机彩色折线</li></ul><p>默认配置为<code>image</code>模式，也就是大图模式。多边形渐变背景<code>trianglify</code>模式来自<a href="https://github.com/qrohlf/trianglify">Trianglify</a>大致如下图：</p><p><img src="https://cloud.githubusercontent.com/assets/347189/6771063/f8b0af46-d090-11e4-8d4c-6c7ef5bd9d37.png" alt=""></p><p>如果你不中意以上两种背景填充方式，可以选择随机彩色折线<code>polyline</code>模式，长相参考下图。</p><blockquote><p>！！注意：如果在使用<code>image</code>模式时<code>url</code>为空（<code>enable</code>仍然保持true）, 主题也会自动使用下面这种<strong><code>漂亮的随机线条</code> </strong>填充（也就是会自动退化为<code>polyline</code>模式）：</p></blockquote><p><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/home-no-background1.png" alt=""></p><h3 id="Code-色彩主题"><a href="#Code-色彩主题" class="headerlink" title="Code 色彩主题"></a>Code 色彩主题</h3><p>Hiker 使用<a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 作为代码高亮的配色. 总共有六种选择: <code>default</code>, <code>normal</code>, <code>night</code>, <code>night blue</code>, <code>night bright</code>, <code>night eighties</code></p><p><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/code-theme-default.png" alt="code `default` theme Preview"></p><p>默认高亮配色如上图。 另外的五种配色如下.</p><p><img src="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/code-theme.jpg?raw=true" alt="code themes"></p><p>Modify <code>highlight_theme</code> in hiker/_config.yml.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Code Highlight theme</span></div><div class="line"><span class="comment"># Available value:</span></div><div class="line"><span class="comment">#    default | normal | night | night eighties | night blue | night bright</span></div><div class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></div><div class="line"><span class="attr">highlight_theme:</span> <span class="string">default</span></div></pre></td></tr></table></figure><h3 id="博客主题色"><a href="#博客主题色" class="headerlink" title="博客主题色"></a>博客主题色</h3><p>Hiker 为你的博客提供了五种可选的主题色，可以配置成<code>random</code>, 每次生成博客时会自动随机使用一个主题色.</p><p><img src="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/theme-color.png?raw=true" alt="theme colors"></p><ul><li><span style="display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #fb6d19; border-radius: 3px; vertical-align: middle;"></span> orange</li><li><span style="display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #00aced; border-radius: 3px; vertical-align: middle;"></span> blue</li><li><span style="display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #f03838; border-radius: 3px; vertical-align: middle;"></span> red</li><li><span style="display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #39aa56; border-radius: 3px; vertical-align: middle;"></span> green</li><li><span style="display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #404040; border-radius: 3px; vertical-align: middle;"></span> black</li></ul><p>You can modify <code>theme_color</code> in hiker/_config.yml.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Article theme color</span></div><div class="line"><span class="comment"># Available value:</span></div><div class="line"><span class="comment">#    random | orange | blue | red | green | black</span></div><div class="line"><span class="attr">theme_color:</span> <span class="string">random</span></div></pre></td></tr></table></figure><h3 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h3><p>只有在文章阅读页面，点击左上角的logo图片，就能打开设置对话框，操作如下图</p><p><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/night-mode.gif" alt=""></p><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>Hiker 使用 <code>Insight Search</code> 实现了站内搜索，在_config.yml文件中启用如下.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Search</span></div><div class="line"><span class="attr">search:</span></div><div class="line"><span class="attr">    insight:</span> <span class="literal">true</span> <span class="comment"># you need to install `hexo-generator-json-content` before using Insight Search</span></div><div class="line"><span class="attr">    swiftype:</span> <span class="comment"># enter swiftype install key here</span></div><div class="line"><span class="attr">    baidu:</span> <span class="literal">false</span> <span class="comment"># you need to disable other search engines to use Baidu search, options: true, false</span></div></pre></td></tr></table></figure><blockquote><p><strong>！注意</strong>: 在使用搜索功能前必须在Hexo目录下使用以下命令安装 <code>hexo-generator-json-content</code> 插件.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -S hexo-generator-json-content</div></pre></td></tr></table></figure><h3 id="Fancybox"><a href="#Fancybox" class="headerlink" title="Fancybox"></a>Fancybox</h3><p>Hiker使用<a href="http://fancyapps.com/fancybox/" target="_blank" rel="external">Fancybox</a>来浏览展示您文章中的图片，支持以下方式在文章中添加图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">![img caption](img url)</div><div class="line"></div><div class="line">&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125;</div></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p><code>sidebar</code>（侧边栏位置）可以设置为 <code>left</code> , <code>right</code>, <code>bottom</code>.</p><p>Hiker 有以下5种侧边栏插件:</p><ul><li>category</li><li>tag</li><li>tagcloud</li><li>archives</li><li>recent_posts</li></ul><p>All of them are enabled by default. You can edit them in <code>widget</code> setting.</p><h3 id="打赏捐赠按钮"><a href="#打赏捐赠按钮" class="headerlink" title="打赏捐赠按钮"></a>打赏捐赠按钮</h3><p><img src="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/donation-btn.png" alt=""></p><p>每篇文章最后显示打赏按钮，目前仅支持微信支付和支付宝两种打赏方式。您可以在文件 <code>hiker/_config.yml</code> 中配置您的微信、支付宝付款二维码图片的URL:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># donation button</span></div><div class="line"><span class="attr">donate:</span></div><div class="line"><span class="attr">    enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    message:</span> <span class="string">'如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!'</span></div><div class="line"><span class="attr">    wechatImage:</span> <span class="attr">https://your_WECHAT_PAY_ImageUrl</span></div><div class="line"><span class="attr">    alipayImage:</span> <span class="attr">https://your_ALIPAY_ImageUrl</span></div></pre></td></tr></table></figure><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>已完全支持原生Disqus、livere（来必力）、wumii（无觅）评论系统。因多说、网易云跟帖均已停止服务，在国内建议大家使用相对稳定的来必力评论系统。在文件 <code>hiker/_config.yml</code> 中修改以下代码片段:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># comment ShortName, you can choose only ONE to display.</span></div><div class="line"><span class="attr">gentie_productKey:</span> <span class="comment">#网易云跟帖your-gentie-product-key</span></div><div class="line"><span class="attr">duoshuo_shortname:</span></div><div class="line"><span class="attr">disqus_shortname:</span></div><div class="line"><span class="attr">livere_shortname:</span> <span class="string">MTAyMC8yOTQ4MS82MDQ5</span></div><div class="line"><span class="attr">uyan_uid:</span></div><div class="line"><span class="attr">wumii:</span></div></pre></td></tr></table></figure><ul><li><h4 id="网易云跟帖说明（已停止服务）"><a href="#网易云跟帖说明（已停止服务）" class="headerlink" title="网易云跟帖说明（已停止服务）"></a>网易云跟帖说明（已停止服务）</h4></li></ul><p>登陆 <a href="https://gentie.163.com/" target="_blank" rel="external">网易云跟帖</a> 获取你的 Product Key。请注意，您在<strong><code>云跟帖管理后台设置的域名必须跟您站点的域名一致</code></strong>。在本地测试时，需要做两步骤前置设定：</p><ol><li>修改 hosts 文件，将您域名的请求指向本地。例如：127.0.0.1 yoursite.com</li><li>修改 Hexo 监听的端口为 80：<code>hexo s --debug -p 80</code></li></ol><p>测试完成后请将 hosts 文件中的域名映射删除即可。</p><h2 id="支持的浏览器"><a href="#支持的浏览器" class="headerlink" title="支持的浏览器"></a>支持的浏览器</h2><p><img src="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/browser-support.png?raw=true" alt=""></p><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><p>欢迎大家有各种问题和改进建议的，直接提issue或者评论，或者pull request都行。我会尽量抽时间和大家交流。刚接触Hexo不久，疏忽不足之处，还望大家海涵！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hiker&quot;&gt;&lt;a href=&quot;#Hiker&quot; class=&quot;headerlink&quot; title=&quot;Hiker&quot;&gt;&lt;/a&gt;Hiker&lt;/h1&gt;&lt;p&gt;An attractive, exquisite theme for &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;. named “Hiker”, short for “HikerNews”.  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://itimetraveler.github.io/hexo-theme-hiker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;☞ 在线预览&lt;/strong&gt;&lt;/a&gt;  |  &lt;a href=&quot;https://gitter.im/hexo-theme-hiker/Lobby?utm_source=share-link&amp;amp;utm_medium=link&amp;amp;utm_campaign=share-link&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Hiker问题交流群&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png&quot; alt=&quot;Desktop Preview&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://github.com/categories/blog/"/>
    
    
      <category term="blog config" scheme="http://github.com/tags/blog-config/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://github.com/2018/04/13/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2018/04/13/背包问题/</id>
    <published>2018-04-12T16:57:50.000Z</published>
    <updated>2018-04-13T07:38:39.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h1><blockquote><p>有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大？</p></blockquote><p>  将每一件物品从1到n编号，从第1件物品开始，每一件物品就只有两个状态：放进背包了 / 没有放进背包。</p><p>  我们画一张表格，行对应着每一件物品，列对应着背包的重量，那么pack[i][j]就表示  <strong>前i件物品，背包最大承重j</strong> 这个子问题的解。</p><a id="more"></a><p> 给一组数据作为样例：</p><pre><code>5 106 23 25 64 56 4</code></pre><p>  第一行表示有5件物品，10为最大承重，2-6行为5个物品的价值和重量。</p><p><strong>生成以下的表格</strong></p><pre><code>0    6    6    6    6     6     6     6     6     60    6    6    9    9     9     9     9     9     90    6    6    9    9     9     9    11    11    140    6    6    9    9     9    10    11    13    140    6    6    9    9    12    12    15    15    15</code></pre><p>　所以最终的结果是最后一行最后一列的 <strong>15</strong></p><p><strong>给出代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* 01 package problem */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> pack[<span class="number">100</span>][<span class="number">1000</span>];</div><div class="line"><span class="keyword">int</span> c[<span class="number">100</span>],w[<span class="number">100</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span>&#123;</div><div class="line"><span class="built_in">memset</span>(pack,<span class="number">0</span>,<span class="keyword">sizeof</span>(pack));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= r; j++)</div><div class="line">            pack[i][j] = max(pack[i - <span class="number">1</span>][j - c[i]] + w[i], pack[i - <span class="number">1</span>][j]);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;pack[n][r];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> t,n,V;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">    <span class="keyword">while</span>(t--)&#123; <span class="comment">//多组数据</span></div><div class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</div><div class="line">        make(n,V);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>代码优化</strong></p><p>这个代码在时间上应该已经不能再优化了，但是还可以考虑空间复杂度的优化。</p><p><strong>优化的基本思路：</strong></p><p>考虑所用到的状态转移方程: <code>pack[i][j] = max(pack[i-1][j-c[i]] + w[i], pack[i-1][j]);</code> 可以发现 <code>pack[i][j]</code> 的值并不和整个二维表的每一个数字的值都有关，而是仅仅和上面一行的值有关，所以可以使用 <code>pack[2][n]</code> 这么大的数组来存储结果。</p><p>考虑状态转移方程的实际情况，还可以使用<strong>一维数组</strong>来进行运算，但是要注意的是，此时，循环应该从后往前进行。因为如果是按从前往后的顺序，那么 <code>pack[i][j] = max(pack[i][j-c[i]] + w[i] , pack[i][j]);</code> 中进行比较的两个值 <code>pack[i][j]</code> 是没有更新的，也就是 <code>pack[i-1][j]</code> 的值，而 <code>pack[i][j - c[i]]</code>一定是前面被更新过的，也就是 <code>pack[i][j-w[i]]</code> 的值。这就是说，<code>max()</code> 比较的两个数是属于原来二维数组中不同的两行，而不是我们期望的相同的两行。</p><p>如果上面的说法不能理解我们不妨这样：有一件物品的性价比很高，在pack数组的某个位置，我们第一次将这个物品放入背包中，但是按照从前往后的顺序，很可能在这个位置的后面某个位置我们会<strong><em>再次</em></strong>将这个物品添加进去。</p><p><strong>优化后的代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> pack[<span class="number">10000</span>],c[<span class="number">1000</span>],w[<span class="number">1000</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(pack,<span class="number">0</span>,<span class="keyword">sizeof</span>(pack));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= w[i]; j--)</div><div class="line">            pack[j] = max(pack[j], pack[j - c[i]] + w[i]);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;pack[r]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,t,V;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">    <span class="keyword">while</span>(t--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</div><div class="line">        make(n,V);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>初始化问题：</strong></p><blockquote><ul><li><p>如果限定背包必须装满，那么需要将数组初始化为 -∞ （负无穷大）</p></li><li><p>如果背包可以不装满，那么数组初始化为0</p></li></ul></blockquote><p><em>为了后面的书写方便，我们把代码改成这样</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> w)</span></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = V; i &gt;= c; i--)</div><div class="line">pack[i] = max(pack[i], pack[i - c] + w);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><em>这样01背包问题的主要代码就是这样：</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">ZeroOnePack(c[i],w[i]);</div></pre></td></tr></table></figure><p>这样ZeroOnePack()这个函数就专门解决了<strong>“放一个物品”</strong>的问题</p><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><blockquote><p>完全背包问题和0/1背包问题几乎一模一样，不同的就是物品不再是一个，而是无数个</p></blockquote><p><strong>思路</strong></p><p>完全背包不同处是原来的一个物品变成了无数个，但是我们还是可以把它变成0/1背包问题的，试想一下，即使拥有无数个物品，但是真的可以用无数个吗？</p><p>不可能，因为背包的容量有限，所以每个物品c,w<strong>最多可以使用[V/c]个</strong>，所以以下面的数据为例：</p><pre><code>c:    3    2    5    4w:    7    4    2    5V = 10</code></pre><p>我们完全可以把这组数据改成这样：</p><pre><code>c:    3    3    3    2    2    2    2    2    5    5    4    4w:    7    7    7    4    4    4    4    4    2    2    5    5</code></pre><p>原因自然是背包容量最大为10,所以占用空间为3的物品最多放3个，修改过后的数据就可以用0/1背包的方法处理</p><p>那难道完全背包需要重开一个c2[],w2[]，然后按0/1背包处理吗？</p><p>当然不是，还记得我们将0/1背包进行优化时说的如果循环从前向后进行会发生什么后果吗？</p><p>这一句 <strong>“但是按照从前往后的顺序，很可能在这个位置的后面某个位置我们会再次将这个物品添加进去。”</strong></p><p>看到了？0/1背包时为了避免重复，我们将循环改为从后往前，但是完全背包是可以重复使用物品的，对吧？所以代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(c,w)</span></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= V; i++)</div><div class="line">pack[i] = max(pack[i],pack[i - c] + w )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>怎么样，和0/1背包只有一点点的差别对不对？</p><h1 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h1><blockquote><p>多重背包和0/1背包不同的地方就是物品不是一个而是有m个</p></blockquote><p>所以我们还是就一个物品c,w,m分析：</p><p>对于m可能有两种情况：</p><ol><li><code>m &gt;= [V/c]</code>，这种情况明显是完全背包</li><li><code>0 &lt; m &lt; [v/c]</code>，对于这种情况需要认真分析一下</li></ol><p>我们仍然需要按照0/1背包的思路把这些物品拆开，而且我们要保证我们拆出来的这些物品可以通过组合表示出1到m任意件物。</p><p>我们可以考虑二进制的计数方法，这样我们把物品拆成<code>(c,w) , (2c,2w) , (4c,4w) …… [(m-2^k)*c , (m-2^k)*w)]</code></p><p>不管最优解会在这件物品中取几件，我们都可以用我们拆出来的这些物品来表示（请自己证明，二进制的思想）</p><p>所以，有了思路，代码就简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(c,w,m)</span></span>&#123;</div><div class="line"><span class="keyword">if</span> (c * m &gt;= V) &#123;</div><div class="line">CompletePack(c,w);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">k = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (k &lt; m) &#123;</div><div class="line">ZeroOnePack(c*k,w*k);</div><div class="line">m = m - k;</div><div class="line">k = <span class="number">2</span> * k;</div><div class="line">&#125;</div><div class="line">ZeroOnePack(c * m, w * m);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><em>其实就是0/1背包和完全背包的组合，有木有？</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0/1背包问题&quot;&gt;&lt;/a&gt;0/1背包问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  将每一件物品从1到n编号，从第1件物品开始，每一件物品就只有两个状态：放进背包了 / 没有放进背包。&lt;/p&gt;
&lt;p&gt;  我们画一张表格，行对应着每一件物品，列对应着背包的重量，那么pack[i][j]就表示  &lt;strong&gt;前i件物品，背包最大承重j&lt;/strong&gt; 这个子问题的解。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="背包问题" scheme="http://github.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="算法" scheme="http://github.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C/C+" scheme="http://github.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown文档中mathjax的问题</title>
    <link href="http://github.com/2018/04/12/markdown%E6%96%87%E6%A1%A3%E4%B8%ADmathjax%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2018/04/12/markdown文档中mathjax的问题/</id>
    <published>2018-04-12T14:35:54.000Z</published>
    <updated>2018-04-12T15:08:49.644Z</updated>
    
    <content type="html"><![CDATA[<p>在写markdown文档时经常会需要插入数学公式，我之前只会使用图片插入，上次在看到mathjax后，我开始了使用mathjax的历程，但在实际写文档的过程中遇到了一些问题。</p><a id="more"></a><h1 id="关于有一些公式无法正确的显示"><a href="#关于有一些公式无法正确的显示" class="headerlink" title="关于有一些公式无法正确的显示"></a>关于有一些公式无法正确的显示</h1><p>在写机器学习的文章中遇到的一个关于范数的公式写出来编辑器上显示没有问题，但是一旦放进文档里就不行了，这个问题困扰了我很长时间。</p><p>这是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</div><div class="line">&gt; $$ \lim_&#123;k\to\infty&#125;\left( \sum_&#123;i=1&#125;^n\mid p_i-q_i\mid ^k\right)^\frac&#123;1&#125;&#123;k&#125; $$</div></pre></td></tr></table></figure></p><p>这是效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim<em>{k\to\infty}\left( \sum</em>{i=1}^n\mid p_i-q_i\mid ^k\right)^\frac{1}{k} $$</p></blockquote><p>这里haroopad显示的公式是正确的，但是hexo编译过后的网页显示就不对了。</p><p>把代码剪裁一下，看看什么样子的公式是可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</div><div class="line">&gt; $$ \lim_&#123;k\to\infty&#125;\left( \sum_i \right) $$</div></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim_{k\to\infty}\left( \sum_i \right) $$</p></blockquote><p>这个好像就可以，但是貌似sum后面的i一旦加上花括号就不行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</div><div class="line">&gt; $$ \lim_&#123;k\to\infty&#125;\left( \sum_&#123;i&#125; \right) $$</div></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim<em>{k\to\infty}\left( \sum</em>{i} \right) $$</p></blockquote><p>于是我点开了两个网页的源代码，定位到这一行：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<span class="tag">&lt;<span class="name">br</span>&gt;</span>$$ \lim<span class="tag">&lt;<span class="name">em</span>&gt;</span>&#123;k\to\infty&#125;\left( \sum<span class="tag">&lt;/<span class="name">em</span>&gt;</span>&#123;i&#125; \right) $$<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<span class="tag">&lt;<span class="name">br</span>&gt;</span>$$ \lim_&#123;k\to\infty&#125;\left( \sum_i \right) $$<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><p>可以发现最明显的不同就算lim后面的 <code>&lt;em&gt;</code>，这时我们注意到，hexo在编译的时候将lim和sum后面的下划线 _翻译成强调的 <code>&lt;em&gt;</code> 了，仔细观察前面的公式，确实可以发现一部分变成了斜体。所以我们要在所有的下划线 _ 前面加上 \ 转义就可以了。</p><p><strong>OK，搞定</strong></p><p><strong><em> p.s 我的chrome上显示的公式后面都有一个竖线，firefox没有，内啥，一般平时用chrome习惯，所以有人知道怎么弄咩？ </em></strong></p><p><strong><em> 上面的问题在重新配置Hexo之后就没有了，个人觉得应该是版本的问题？ </em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写markdown文档时经常会需要插入数学公式，我之前只会使用图片插入，上次在看到mathjax后，我开始了使用mathjax的历程，但在实际写文档的过程中遇到了一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://github.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://github.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 3</title>
    <link href="http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-3/"/>
    <id>http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-3/</id>
    <published>2018-04-12T09:09:44.000Z</published>
    <updated>2018-04-12T14:57:16.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-Localization"><a href="#Object-Localization" class="headerlink" title="Object Localization"></a>Object Localization</h3><p>Object localization用来识别图像中是否包含特定对象以及该对象的位置，并最终使用一个矩形框在图像中标出该特定对象。为了简化问题，在这里我们假设图片中最多包含一个待识别的对象。下面对问题进行形式化描述。</p><p>定义目标变量$y$ (同时也是神经网络的输出层)，<br>$$<br>y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T<br>\tag{1}<br>$$<br><a id="more"></a></p><p>其中，$P_c$表示图像中是否包含特定对象，$(b_x, b_y)$表示特定对象的中心位置在图像中的坐标（图像左上角坐标为$(0,0)$，右下角坐标为$(1,1)$），$b_h,b_w$分别表示特定对象的高度和宽度，$C_1-C_3$表示特定对象的类型（行人，汽车，摩托车）。</p><p>定义损失函数$\mathcal{L(\hat{y}, y)}$，<br>$$<br>\mathcal{L}(\hat{y}, y) =<br>\begin{split}<br>\begin{cases}<br>\sum_{i=1}^{i=8} (\hat{y}_i - y_i)^2,&amp;~if~y_1=1 \\<br>(\hat{y}_1 - y_1)^2,&amp;~if~y_1=0<br>\end{cases}<br>\end{split}<br>$$<br>这里针对不同的维度都使用了平方差损失函数，可以针对不同的维度使用不同的损失函数。</p><h3 id="Landmark-Detection"><a href="#Landmark-Detection" class="headerlink" title="Landmark Detection"></a>Landmark Detection</h3><p>有时我们需要识别图中的一些关键点的坐标，这些坐标称为Landmarks。这时候，我们可以定义如下的目标变量$y$<br>$$<br>y = [P~l_{x1}~l_{y1}~\dots~l_{xn}~l_{yn}]^T<br>$$<br>以识别人面部眼角嘴角为例，其中$P$代表是否包含人脸，$(l_{xi}, l_{yi})$代表关键点的坐标。</p><h3 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h3><p> Object Detction的其中一种办法叫做Sliding windows detection，采用不同尺寸的矩形框，从左至右、从上到下遍历枚举图像的子图，判断子图中是否包含需要的目标对象。很明显，这种办法比较笨，需要消耗大量的计算量。</p><h3 id="Convolutional-Implementation-of-Sliding-Windows"><a href="#Convolutional-Implementation-of-Sliding-Windows" class="headerlink" title="Convolutional Implementation of Sliding Windows"></a>Convolutional Implementation of Sliding Windows</h3><p>全连接是可以通过卷积来实现的，并且两者直接是等价的。例如，如果$5\times 5 \times 16$的卷积层之后接的是一个$400$个神经元的全连接层，那么它等价于$5 \times 5 \times 16$的卷积层之后采用400个$5 \times 5 \times 16$的filters得到的$1 \times 1 \times 400$的卷积层。</p><p>得益于卷积的存在，Sliding windows detection可以做到同时预测同一张图像不同子图中是否包含特定对象。但是这样做的不利条件是预测出来的对象的边界（bounding box）会相对不准确。因为这种办法采用的是子图的边界来作为待预测对象的边界。</p><h3 id="Bounding-Box-Predictions"><a href="#Bounding-Box-Predictions" class="headerlink" title="Bounding Box Predictions"></a>Bounding Box Predictions</h3><p>这里介绍了YOLO algorithm (You Only Look Once)，该算法用来识别同一张图像上的多个目标简单。它将图像切分为了$M \times N$的网格并在此基础上构造了卷积神经网络。该网络的输入依然为整张图片，切分并不影响输入，而是决定了网络的输出尺寸为$M \times N \times 8$。这样，每个子图就拥有了一个$1 \times 1 \times 8$的预测结果，用来表示图像中是否包含特定的对象，如果包含的话，该特定对象的中心位置、长宽以及类别分别是什么。</p><p>该算法利用了卷积操作提高了对同一张图像上不同子图的模型训练预测的效率，使得一次训练就可以完成对多个子图的建模（这里有个假设，就是每个子图上只包含最多一个特定对象）。</p><h3 id="Intersection-Over-Union"><a href="#Intersection-Over-Union" class="headerlink" title="Intersection Over Union"></a>Intersection Over Union</h3><p>$$<br>Intersection over Union (loU) = \frac{size~of~intersection}{size~of~union}<br>$$</p><p>通过loU，我们可以知道两个矩形在大小和位置上的相像程度。这样，我们就可以用它来评价object detection算法的优劣。</p><h3 id="Non-max-Suppression"><a href="#Non-max-Suppression" class="headerlink" title="Non-max Suppression"></a>Non-max Suppression</h3><p>有时候，我们的算法会将相同的对象识别多次，non-max suppression算法用来解决这个问题。举例，</p><p>假设卷积神经网络最后的输出为$19 \times 19 \times 5$，也就是说图像被切分为了$19 \times 19$的子图，每个子图的预测结果为一个5维的向量，该向量如下，<br>$$<br>y = [p_c~b_x~b_y~b_h~b_w]^T<br>$$<br>那么，在训练结束之后，non-max suppression算法会执行如下步骤，</p><ol><li>扔掉所有$p_c \le 0.6$的bounding boxes</li><li>取出剩余bounding boxes中$p_c$最大的那个bounding box，作为新检测到的目标</li><li>删除剩余所有与该box的loU值$\ge 0.5$的bounding boxes</li><li>重复(2-3)步，直到没有bounding boxes剩余</li></ol><p>从上可以看出，non-max suppression其实是个简单的贪心算法。</p><h3 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h3><p>在Object detection问题中，还有一个难点就是图像划分出网格后，每个网格中只能最多识别一个对象。为了让单个网格识别多个对象，可以采用Anchor boxes方法。</p><p>Anchor boxes方法的思想很简单，将式(1)改为如下形式，<br>$$<br>y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3~P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T<br>\tag{2}<br>$$<br>式(2)表示在识别的过程中采用了两个Anchor box。每个Anchor box都负责识别所有类别的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object-Localization&quot;&gt;&lt;a href=&quot;#Object-Localization&quot; class=&quot;headerlink&quot; title=&quot;Object Localization&quot;&gt;&lt;/a&gt;Object Localization&lt;/h3&gt;&lt;p&gt;Object localization用来识别图像中是否包含特定对象以及该对象的位置，并最终使用一个矩形框在图像中标出该特定对象。为了简化问题，在这里我们假设图片中最多包含一个待识别的对象。下面对问题进行形式化描述。&lt;/p&gt;
&lt;p&gt;定义目标变量$y$ (同时也是神经网络的输出层)，&lt;br&gt;$$&lt;br&gt;y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T&lt;br&gt;\tag{1}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
      <category term="deep-learning" scheme="http://github.com/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 1</title>
    <link href="http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-1/"/>
    <id>http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-1/</id>
    <published>2018-04-12T09:09:44.000Z</published>
    <updated>2018-04-12T12:42:44.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Computer-Vision"><a href="#Computer-Vision" class="headerlink" title="Computer Vision"></a>Computer Vision</h3><p>Computer Vision Problems include:</p><ul><li>Image Classication</li><li>Object Detection</li><li>… …</li></ul><p>One of the challenges of computer vision problems is that the input can be very big. For example, a 1000 by 1000 image can have $1000 \times  64 \times 3 = 12288$ dimensions because there are three color channels. If the size of hidden layer is 1000, the number of parameters from input layer to hidden layer could be 3 billion. This will cause these problems:</p><ol><li>data size requirements;</li><li>computational requirements;</li><li>memory requirements.</li></ol><a id="more"></a><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>The problems of convolutional operation:</p><ol><li>shrinking output</li><li>throwing away a lot of information from the edges of the image</li></ol><p>In order to fix these problems, what we need to do is <strong>pad the image</strong>.</p><p>通常有两种padding的方式：</p><ul><li>Valid convolution: 意思是不采用padding的方式。</li><li>Same convolution：意思是输出的尺寸和输入的尺寸相同。<ul><li>在这种情况下可以推导出$p = \frac{f-1}{2}$，所以在计算机视觉的模型中，filter的尺寸通常是奇数而不是偶数。</li><li>Filter的尺寸是奇数还有另外一个好处，就是filter可以有中心像素，可以很方便的用来定位filter的位置。</li></ul></li></ul><h3 id="Strided-Convolutions"><a href="#Strided-Convolutions" class="headerlink" title="Strided Convolutions"></a>Strided Convolutions</h3><p>给定如下条件，<br>$$<br>\begin{split}<br>&amp;n\times n~image~~~~&amp;f\times f~filter\\<br>&amp;padding~p&amp;stride~s<br>\end{split}<br>$$<br>经过Strided Convolutions之后得到的tensor的尺寸为，<br>$$<br>\lfloor \frac{n + 2p - f}{s} + 1 \rfloor \times \lfloor \frac{n + 2p - f}{s} + 1 \rfloor<br>$$</p><blockquote><p>NG在这里提到，我们所谓的convolution并不是真正意义上的卷积，而是应该称为cross-correlation，它之前实际上应该有一个针对卷积核的变换操作，这些操作再加上cross-correlation才是真正的convolution。但是这个变换操作没什么用处，所以通常情况下就省略了。</p></blockquote><h3 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h3><p>在RGB类型的多通道图像中使用Multiple filters：<br>$$<br>n \times n \times n_c \ast f\times f \times n_c \rightarrow (n - f + 1) \times (n - f + 1) \times {n_c}’<br>$$<br>其中，$n$表示图像的长宽，$f$表示filter的长宽，$n_c$表示图像的通道数，$n_c’$表示filter的个数。</p><h3 id="One-Layer-of-a-Convolutional-Network"><a href="#One-Layer-of-a-Convolutional-Network" class="headerlink" title="One Layer of a Convolutional Network"></a>One Layer of a Convolutional Network</h3><p>普通的BP神经网络的数学表达形式如下：<br>$$<br>\begin{split}<br>z^{[1]} &amp;= w^{[1]} a^{[0]} + b^{[1]} \\<br>a^{[1]} &amp;= g(z^{[1]})<br>\end{split}<br>$$<br>在CNN中，convolution operation相当于$w^{[1]}a^{[0]}$，也就是充当了原先线性变换的角色。</p><p>这里对卷积层中涉及到的符号进行总结，<br>$$<br>\begin{split}<br>f^{[l]} &amp;= filter~size \\<br>p^{[l]} &amp;= padding \\<br>s^{[l]} &amp;= stride \\<br>n_{C}^{[l]} &amp;= number~of~filters<br>\end{split}<br>\tag{1}<br>$$<br>接着定义卷积层的输入和输出表示，<br>$$<br>\begin{split}<br>Input:~&amp;n_H^{[l-1]} \times n_W^{[l-1]} \times n_C^{[l-1]} \\<br>Output:~&amp;n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]}<br>\end{split}<br>\tag{2}<br>$$</p><p>基于(1)和(2)，我们可以进行如下定义，<br>$$<br>\begin{split}<br>&amp;Each~filter~is:~    &amp;f^{[l]} \times f^{[l]} \times n_C^{[l-1]} \\<br>&amp;Activations:~        &amp;a^{[l]} \rightarrow n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]} \\<br>&amp;Weights:~        &amp;f^{[l]} \times f^{[l]} \times n_C^{[l-1]} \times n_C^{[l]} \\<br>&amp;bias:~            &amp;n_C^{[l]}<br>\end{split}<br>\tag{3}<br>$$<br>在式(2)中，$n_H^{[l]}$与$n_H^{[l-1]}$的关系如下，<br>$$<br>n_H^{[l]} = \lfloor \frac{n_H^{[l - 1]} + 2p^{[l]} - f^{[l]}}{s^{l}} + 1 \rfloor<br>$$<br>在式(3)中，Activations是单个样本的形式，batch的形式如下，<br>$$<br>A^{[l]} \rightarrow m \times n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]}<br>$$</p><h3 id="Simple-Convolution-Network-Example"><a href="#Simple-Convolution-Network-Example" class="headerlink" title="Simple Convolution Network Example"></a>Simple Convolution Network Example</h3><p>以图像分类为例（识别图片中是否有猫），经过若干卷积层之后，为了得到最终的$0/1$分类结果，会将最后一层卷积的tensor展开并拉长成vector，经过logistic/softmax单元后得到代表预测结果的概率值。</p><p>在使用ConvNet的过程中，比较麻烦的地方在于如何确定超参。有一个常用的指导方针是，activations的长和宽需要越来越小（也就是图片的尺寸越来越小），同时通道数需要越来越多（也就是activations的第三个维度）。之后会详细介绍怎么需选择超参。</p><p>在ConvNet中，通常有三种类型的网络层，</p><ul><li>Convolution (CONV)</li><li>Pooling (POOL)</li><li>Fully connected (FC)</li></ul><h3 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h3><p>Pooling Layer有如下好处，</p><ul><li>减少图像representation的尺寸，提高计算速度</li><li>提高鲁棒性</li></ul><p>很有意思的地方在于，对于pooling layer来说，我们只需要确定超参数$f^{[l]}$和$s^{[l]}$，以及是max pooling 还是average pooling，并不需要进行参数的学习。</p><p>在pooling layer中，超参$p^{[l]}$通常设置为0。</p><h3 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h3><p>神经网络中常用的一种模式是，若干卷积层之后加池化层，再若干层卷积层之后接池化层，然后接全连接层，最后给softmax单元。NG在课上画了一个例子如下，</p><div align="center"><br><br><img src="https://raw.githubusercontent.com/HouJP/my-hexo/master/source/img/cnn-w1/cnn-example.jpeg" alt="cnn-example"><br><br></div><h3 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions"></a>Why Convolutions</h3><p>卷积层最显著的特点就是参数数量大大小于全连接层的数量，因为：</p><ol><li>Parameter sharing: 图像的不同位置共享filters。</li><li>Sparsity of connections: 每个输出值只取决于很小的一部分输入。这样也降低了过拟合的风险。</li></ol><p>卷积神经网络的损失函数定义如下所示，<br>$$<br>Cost~J = \frac{1}{m} \sum_{i-1}^{m} \mathcal{L}(\hat{y}^{(i)}, y^{(i)})<br>$$</p><h3 id="Programming-Assignments"><a href="#Programming-Assignments" class="headerlink" title="Programming Assignments"></a>Programming Assignments</h3><h4 id="Convolutional-Model-step-by-step"><a href="#Convolutional-Model-step-by-step" class="headerlink" title="Convolutional Model: step by step"></a>Convolutional Model: step by step</h4><p>卷积层和池化层的区别：</p><ul><li>卷积层中的每个filter都会同时作用在不同的channel上</li><li>在池化层中，filter与channel一一对应，作用在对应的channel上</li></ul><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="http://www.cnblogs.com/nowgood/p/Latexstart.html" target="_blank" rel="external">MarkDown中使用Latex数学公式</a></li><li><a href="http://masikkk.com/article/hexo-13-MathJax/" target="_blank" rel="external">Hexo博客(13)添加MathJax数学公式渲染</a><ul><li>解释了Markdown和Mathjax渲染冲突问题</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Computer-Vision&quot;&gt;&lt;a href=&quot;#Computer-Vision&quot; class=&quot;headerlink&quot; title=&quot;Computer Vision&quot;&gt;&lt;/a&gt;Computer Vision&lt;/h3&gt;&lt;p&gt;Computer Vision Problems include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Image Classication&lt;/li&gt;
&lt;li&gt;Object Detection&lt;/li&gt;
&lt;li&gt;… …&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of the challenges of computer vision problems is that the input can be very big. For example, a 1000 by 1000 image can have $1000 \times  64 \times 3 = 12288$ dimensions because there are three color channels. If the size of hidden layer is 1000, the number of parameters from input layer to hidden layer could be 3 billion. This will cause these problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;data size requirements;&lt;/li&gt;
&lt;li&gt;computational requirements;&lt;/li&gt;
&lt;li&gt;memory requirements.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="deep-learning" scheme="http://github.com/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 4</title>
    <link href="http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-4/"/>
    <id>http://github.com/2018/04/12/Convolutional-Neural-Networks-Week-4/</id>
    <published>2018-04-12T09:09:44.000Z</published>
    <updated>2018-04-12T15:06:09.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-Face-Recognition"><a href="#What-is-Face-Recognition" class="headerlink" title="What is Face Recognition"></a>What is Face Recognition</h3><p>这里区分两个概念，<code>Face verification</code>和<code>Face recognition</code>，</p><ul><li>Verification<ul><li>输入：图像 + 名字/ID</li><li>输出：输入的图像上是否有名字/ID表示的那个人</li></ul></li><li>Recognition<ul><li>数据库中有$K$个人</li><li>输入：图像</li><li>输出：图像上有的数据库中的人的名字/ID</li></ul></li></ul><p>很明显，Recognition比Verification的难度要大得多。<br><a id="more"></a></p><h3 id="One-Shot-Learning"><a href="#One-Shot-Learning" class="headerlink" title="One Shot Learning"></a>One Shot Learning</h3><p>什么是One-shot learning，</p><blockquote><p>Learning from one example to recognize the person again.</p></blockquote><p>很多时候公司的数据库中只有一张员工的照片，那么我们在做人脸识别系统的时候怎么根据这一张照片来再次识别相同的人的影像？如果用传统的卷积神经网络来做的话，因为训练数据很小，所以通常效果并不理想。</p><p>在这种情况下，我们应该学习”similarity” function,<br>$$<br>d(img1, img2) = degree~of~difference~between~images<br>$$<br>然后可以根据Similarity function完成verification,<br>$$<br>\begin{split}<br>If~d(img1, img2) &amp;\le \tau~same\\<br>&amp;&gt; \tau~different<br>\end{split}<br>$$</p><h3 id="Siamese-Network"><a href="#Siamese-Network" class="headerlink" title="Siamese Network"></a>Siamese Network</h3><p>Parameters of NN define an encoding $f(x^{(i)})$</p><p>Learn parameters so that:</p><ul><li>If $x^{(i)}, x^{(j)}$ are the same person, $| f(x^{(i)}) - f(x^{(j)}) |^2$ is small</li><li>If $x^{(i)}, x^{(j)}$ are the different person, $| f(x^{(i)}) - f(x^{(j)}) |^2$ is large</li></ul><p>那么，该网络学习的目标函数应该怎么定义呢？</p><h3 id="Triple-Loss"><a href="#Triple-Loss" class="headerlink" title="Triple Loss"></a>Triple Loss</h3><p>在Triple loss中，基准人脸图像称为Anchor image，正样本为Positive image，负样本为Negative image，那么我们希望得到的是，<br>$$<br>|f(A) - f(P) | ^2 \le | f(A) - f(N) | ^2<br>$$<br>也就是，<br>$$<br>|f(A) - f(P) | ^2 - | f(A) - f(N) | ^2 \le 0<br>$$<br>这里有个问题，如果$f$始终预测0，那么上述条件始终满足。为了防止这种情况发生，所以需要增加一个超参$\alpha$，也称为margin，<br>$$<br>|f(A) - f(P) | ^2 - | f(A) - f(N) | ^2 + \alpha \le 0<br>$$<br>下面对Loss function进行形式化定义，给定3个图像 A, P, N，<br>$$<br>\mathcal{L}(A, P, N) = max(|f(A) - f(P)|^2 -|f(A) - f(N)|^2  + \alpha, 0)<br>$$<br>在整体样本上的损失为，<br>$$<br>J = \sum_{i=1}^{M} \mathcal{L}(A^{(i)}, P^{(i)}, N^{(i)})<br>$$<br>很明显，在训练样本中，一个人需要有多张照片才能组合出这样的三元组。</p><p>那么，应该怎么选择三元组呢，</p><ul><li>During training, if A, P, N are chsen randomly, $d(A, P) + \alpha \le d(A, N)$ is easily satisfied.<ul><li>这种方法容易选择，但是训练出来的模型效果一般</li></ul></li><li>Choose triplets that’re “hard” to train on.<ul><li>这种方法不容易选择，但是模型能学习到更多的信息。</li></ul></li></ul><h3 id="Face-Verification-and-Binary-Classification"><a href="#Face-Verification-and-Binary-Classification" class="headerlink" title="Face Verification and Binary Classification"></a>Face Verification and Binary Classification</h3><p>另一种similarity function，以一对图像作为输入，<br>$$<br>\hat{y} = \delta ( \sum_{k=1}^{128} w_i | f(x^{(i)})_k - f(x^{(j)})_k   | + b  )<br>$$<br>其中，$f(x^{(i)})$表示对第i张图像的128维的embedding表达。</p><h3 id="What-are-deep-ConvNets-Learning"><a href="#What-are-deep-ConvNets-Learning" class="headerlink" title="What are deep ConvNets Learning"></a>What are deep ConvNets Learning</h3><p>这里介绍了怎么将卷积神经网络的hidden layer可视化。以第一层为例，</p><blockquote><p>Pick a unit in layer 1. Find the nine image patches that maximize the unit’s activation.</p><p>Repeat for other units.</p></blockquote><p>可以看到，每个unit’s activation针对的方向不同，有的是颜色，有的是不同方向的边。随着网络深度的增加，每个unit’s activation可以看到的图像的范围越来越大。</p><h3 id="Neural-Style-Transfer-Cost-Function"><a href="#Neural-Style-Transfer-Cost-Function" class="headerlink" title="Neural Style Transfer Cost Function"></a>Neural Style Transfer Cost Function</h3><p>原始内容图片为C，风格图片为S，目标图片为G，那么，$G_{kk’}^{[l]}$<br>$$<br>J(G) = \alpha J_{content}(C, G) + \beta J_{style}(S, G)<br>$$</p><p>下面介绍Style matrix,<br>$$<br>\begin{split}<br>&amp; Let~a_{i,j,k}^{[l]} &amp;= activation~at~(i,j,k). G^{[l]}~is~n_c^{[l]} \times n_c^{[l]} \\<br>\rightarrow &amp; G_{kk’}^{[l]} &amp;= \sum_{i=1}^{n_H^{[l]}} \sum_{j=1}^{[n_W]^{[l]}} a_{ijk}^{[l]} a_{ijk’}^{[l]}<br>\end{split}<br>$$<br>其中，$G^{[l]}$为Style matrix。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-Face-Recognition&quot;&gt;&lt;a href=&quot;#What-is-Face-Recognition&quot; class=&quot;headerlink&quot; title=&quot;What is Face Recognition&quot;&gt;&lt;/a&gt;What is Face Recognition&lt;/h3&gt;&lt;p&gt;这里区分两个概念，&lt;code&gt;Face verification&lt;/code&gt;和&lt;code&gt;Face recognition&lt;/code&gt;，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification&lt;ul&gt;
&lt;li&gt;输入：图像 + 名字/ID&lt;/li&gt;
&lt;li&gt;输出：输入的图像上是否有名字/ID表示的那个人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Recognition&lt;ul&gt;
&lt;li&gt;数据库中有$K$个人&lt;/li&gt;
&lt;li&gt;输入：图像&lt;/li&gt;
&lt;li&gt;输出：图像上有的数据库中的人的名字/ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很明显，Recognition比Verification的难度要大得多。&lt;br&gt;
    
    </summary>
    
      <category term="deep-learning" scheme="http://github.com/categories/deep-learning/"/>
    
    
  </entry>
  
</feed>
